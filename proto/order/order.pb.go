// Code generated by protoc-gen-gogo.
// source: order/order.proto
// DO NOT EDIT!

/*
	Package order is a generated protocol buffer package.

	It is generated from these files:
		order/order.proto

	It has these top-level messages:
		Order
		Execution
		Allocation
		NewOrderRequest
		NewOrderResponse
		CancelOrderRequest
		CancelOrderResponse
		ReplaceOrderRequest
		ReplaceOrderResponse
*/
package order

import proto "github.com/gogo/protobuf/proto"
import math "math"

// discarding unused import gogoproto "github.com/gogo/protobuf/gogoproto/gogo.pb"

import io "io"
import fmt "fmt"
import github_com_gogo_protobuf_proto "github.com/gogo/protobuf/proto"

import strings "strings"
import reflect "reflect"

import sort "sort"
import strconv "strconv"

import bytes "bytes"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = math.Inf

type OrderStatus int32

const (
	OrderStatus_NEW                  OrderStatus = 0
	OrderStatus_PARTIALLY_FILLED     OrderStatus = 1
	OrderStatus_FILLED               OrderStatus = 2
	OrderStatus_DONE_FOR_DAY         OrderStatus = 3
	OrderStatus_CANCELLED            OrderStatus = 4
	OrderStatus_REPLACED             OrderStatus = 5
	OrderStatus_PENDING_CANCEL       OrderStatus = 6
	OrderStatus_STOPPED              OrderStatus = 7
	OrderStatus_REJECTED             OrderStatus = 8
	OrderStatus_SUSPENDED            OrderStatus = 9
	OrderStatus_PENDING_NEW          OrderStatus = 10
	OrderStatus_CALCULATED           OrderStatus = 11
	OrderStatus_EXPIRED              OrderStatus = 12
	OrderStatus_ACCEPTED_FOR_BIDDING OrderStatus = 13
	OrderStatus_PENDING_REPLACE      OrderStatus = 14
	OrderStatus_ORDER_RECEIVED       OrderStatus = 100
	OrderStatus_ORDER_SENT           OrderStatus = 101
	OrderStatus_MC_ACK_ORDER         OrderStatus = 102
	OrderStatus_MC_SENT_ORDER        OrderStatus = 103
	OrderStatus_CANCEL_RECEIVED      OrderStatus = 110
	OrderStatus_CANCEL_SENT          OrderStatus = 111
	OrderStatus_MC_ACK_CANCEL        OrderStatus = 112
	OrderStatus_MC_SENT_CANCEL       OrderStatus = 113
	OrderStatus_REPLACE_RECEIVED     OrderStatus = 120
	OrderStatus_REPLACE_SENT         OrderStatus = 121
	OrderStatus_MC_ACK_REPLACE       OrderStatus = 122
	OrderStatus_MC_SENT_REPLACE      OrderStatus = 123
	OrderStatus_EXECUTION_REPLACED   OrderStatus = 125
	OrderStatus_EXECUTION_CANCELLED  OrderStatus = 126
	OrderStatus_BOOKABLE             OrderStatus = 130
	OrderStatus_TRADE_PUMP_RECEIVED  OrderStatus = 131
	OrderStatus_TRADE_PUMP_PROCESSED OrderStatus = 132
	OrderStatus_BOOKING              OrderStatus = 133
	OrderStatus_SENT_PMS             OrderStatus = 134
	OrderStatus_BOOKED               OrderStatus = 135
)

var OrderStatus_name = map[int32]string{
	0:   "NEW",
	1:   "PARTIALLY_FILLED",
	2:   "FILLED",
	3:   "DONE_FOR_DAY",
	4:   "CANCELLED",
	5:   "REPLACED",
	6:   "PENDING_CANCEL",
	7:   "STOPPED",
	8:   "REJECTED",
	9:   "SUSPENDED",
	10:  "PENDING_NEW",
	11:  "CALCULATED",
	12:  "EXPIRED",
	13:  "ACCEPTED_FOR_BIDDING",
	14:  "PENDING_REPLACE",
	100: "ORDER_RECEIVED",
	101: "ORDER_SENT",
	102: "MC_ACK_ORDER",
	103: "MC_SENT_ORDER",
	110: "CANCEL_RECEIVED",
	111: "CANCEL_SENT",
	112: "MC_ACK_CANCEL",
	113: "MC_SENT_CANCEL",
	120: "REPLACE_RECEIVED",
	121: "REPLACE_SENT",
	122: "MC_ACK_REPLACE",
	123: "MC_SENT_REPLACE",
	125: "EXECUTION_REPLACED",
	126: "EXECUTION_CANCELLED",
	130: "BOOKABLE",
	131: "TRADE_PUMP_RECEIVED",
	132: "TRADE_PUMP_PROCESSED",
	133: "BOOKING",
	134: "SENT_PMS",
	135: "BOOKED",
}
var OrderStatus_value = map[string]int32{
	"NEW":                  0,
	"PARTIALLY_FILLED":     1,
	"FILLED":               2,
	"DONE_FOR_DAY":         3,
	"CANCELLED":            4,
	"REPLACED":             5,
	"PENDING_CANCEL":       6,
	"STOPPED":              7,
	"REJECTED":             8,
	"SUSPENDED":            9,
	"PENDING_NEW":          10,
	"CALCULATED":           11,
	"EXPIRED":              12,
	"ACCEPTED_FOR_BIDDING": 13,
	"PENDING_REPLACE":      14,
	"ORDER_RECEIVED":       100,
	"ORDER_SENT":           101,
	"MC_ACK_ORDER":         102,
	"MC_SENT_ORDER":        103,
	"CANCEL_RECEIVED":      110,
	"CANCEL_SENT":          111,
	"MC_ACK_CANCEL":        112,
	"MC_SENT_CANCEL":       113,
	"REPLACE_RECEIVED":     120,
	"REPLACE_SENT":         121,
	"MC_ACK_REPLACE":       122,
	"MC_SENT_REPLACE":      123,
	"EXECUTION_REPLACED":   125,
	"EXECUTION_CANCELLED":  126,
	"BOOKABLE":             130,
	"TRADE_PUMP_RECEIVED":  131,
	"TRADE_PUMP_PROCESSED": 132,
	"BOOKING":              133,
	"SENT_PMS":             134,
	"BOOKED":               135,
}

func (x OrderStatus) Enum() *OrderStatus {
	p := new(OrderStatus)
	*p = x
	return p
}
func (x OrderStatus) String() string {
	return proto.EnumName(OrderStatus_name, int32(x))
}
func (x *OrderStatus) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(OrderStatus_value, data, "OrderStatus")
	if err != nil {
		return err
	}
	*x = OrderStatus(value)
	return nil
}

type Side int32

const (
	Side_UNKNOWN_SIDE       Side = 0
	Side_BUY                Side = 1
	Side_SELL               Side = 2
	Side_BUY_MINUS          Side = 3
	Side_SELL_PLUS          Side = 4
	Side_SELL_SHORT         Side = 5
	Side_SELL_SHORT_EXEMPT  Side = 6
	Side_UNDISCLOSED        Side = 7
	Side_CROSS              Side = 8
	Side_CROSS_SHORT        Side = 9
	Side_CROSS_SHORT_EXEMPT Side = 10
	Side_AS_DEFINED         Side = 11
	Side_OPPOSITE           Side = 12
	Side_SUBSCRIBE          Side = 13
	Side_REDEEM             Side = 14
	Side_LEND               Side = 15
	Side_BORROW             Side = 16
)

var Side_name = map[int32]string{
	0:  "UNKNOWN_SIDE",
	1:  "BUY",
	2:  "SELL",
	3:  "BUY_MINUS",
	4:  "SELL_PLUS",
	5:  "SELL_SHORT",
	6:  "SELL_SHORT_EXEMPT",
	7:  "UNDISCLOSED",
	8:  "CROSS",
	9:  "CROSS_SHORT",
	10: "CROSS_SHORT_EXEMPT",
	11: "AS_DEFINED",
	12: "OPPOSITE",
	13: "SUBSCRIBE",
	14: "REDEEM",
	15: "LEND",
	16: "BORROW",
}
var Side_value = map[string]int32{
	"UNKNOWN_SIDE":       0,
	"BUY":                1,
	"SELL":               2,
	"BUY_MINUS":          3,
	"SELL_PLUS":          4,
	"SELL_SHORT":         5,
	"SELL_SHORT_EXEMPT":  6,
	"UNDISCLOSED":        7,
	"CROSS":              8,
	"CROSS_SHORT":        9,
	"CROSS_SHORT_EXEMPT": 10,
	"AS_DEFINED":         11,
	"OPPOSITE":           12,
	"SUBSCRIBE":          13,
	"REDEEM":             14,
	"LEND":               15,
	"BORROW":             16,
}

func (x Side) Enum() *Side {
	p := new(Side)
	*p = x
	return p
}
func (x Side) String() string {
	return proto.EnumName(Side_name, int32(x))
}
func (x *Side) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Side_value, data, "Side")
	if err != nil {
		return err
	}
	*x = Side(value)
	return nil
}

type OrderType int32

const (
	OrderType_UNKNOWN_ORDER_TYPE            OrderType = 0
	OrderType_MARKET                        OrderType = 1
	OrderType_LIMIT                         OrderType = 2
	OrderType_STOP                          OrderType = 3
	OrderType_STOP_LIMIT                    OrderType = 4
	OrderType_MARKET_ON_CLOSE               OrderType = 5
	OrderType_WITH_OR_WITHOUT               OrderType = 6
	OrderType_LIMIT_OR_BETTER               OrderType = 7
	OrderType_LIMIT_WITH_OR_WITHOUT         OrderType = 8
	OrderType_ON_BASIS                      OrderType = 9
	OrderType_ON_CLOSE                      OrderType = 10
	OrderType_LIMIT_ON_CLOSE                OrderType = 11
	OrderType_FOREX_MARKET                  OrderType = 12
	OrderType_PREVIOUSLY_QUOTED             OrderType = 13
	OrderType_PREVIOUSLY_INDICATED          OrderType = 14
	OrderType_FOREX_LIMIT                   OrderType = 15
	OrderType_FOREX_SWAP                    OrderType = 16
	OrderType_FOREX_PREVIOUSLY_QUOTED       OrderType = 17
	OrderType_FUNARI                        OrderType = 18
	OrderType_MARKET_IF_TOUCHED             OrderType = 19
	OrderType_MARKET_WITH_LEFTOVER_AS_LIMIT OrderType = 20
	OrderType_PREVIOUS_FUND_VALUATION_POINT OrderType = 21
	OrderType_NEXT_FUND_VALUATION_POINT     OrderType = 22
	OrderType_PEGGED                        OrderType = 23
)

var OrderType_name = map[int32]string{
	0:  "UNKNOWN_ORDER_TYPE",
	1:  "MARKET",
	2:  "LIMIT",
	3:  "STOP",
	4:  "STOP_LIMIT",
	5:  "MARKET_ON_CLOSE",
	6:  "WITH_OR_WITHOUT",
	7:  "LIMIT_OR_BETTER",
	8:  "LIMIT_WITH_OR_WITHOUT",
	9:  "ON_BASIS",
	10: "ON_CLOSE",
	11: "LIMIT_ON_CLOSE",
	12: "FOREX_MARKET",
	13: "PREVIOUSLY_QUOTED",
	14: "PREVIOUSLY_INDICATED",
	15: "FOREX_LIMIT",
	16: "FOREX_SWAP",
	17: "FOREX_PREVIOUSLY_QUOTED",
	18: "FUNARI",
	19: "MARKET_IF_TOUCHED",
	20: "MARKET_WITH_LEFTOVER_AS_LIMIT",
	21: "PREVIOUS_FUND_VALUATION_POINT",
	22: "NEXT_FUND_VALUATION_POINT",
	23: "PEGGED",
}
var OrderType_value = map[string]int32{
	"UNKNOWN_ORDER_TYPE":            0,
	"MARKET":                        1,
	"LIMIT":                         2,
	"STOP":                          3,
	"STOP_LIMIT":                    4,
	"MARKET_ON_CLOSE":               5,
	"WITH_OR_WITHOUT":               6,
	"LIMIT_OR_BETTER":               7,
	"LIMIT_WITH_OR_WITHOUT":         8,
	"ON_BASIS":                      9,
	"ON_CLOSE":                      10,
	"LIMIT_ON_CLOSE":                11,
	"FOREX_MARKET":                  12,
	"PREVIOUSLY_QUOTED":             13,
	"PREVIOUSLY_INDICATED":          14,
	"FOREX_LIMIT":                   15,
	"FOREX_SWAP":                    16,
	"FOREX_PREVIOUSLY_QUOTED":       17,
	"FUNARI":                        18,
	"MARKET_IF_TOUCHED":             19,
	"MARKET_WITH_LEFTOVER_AS_LIMIT": 20,
	"PREVIOUS_FUND_VALUATION_POINT": 21,
	"NEXT_FUND_VALUATION_POINT":     22,
	"PEGGED":                        23,
}

func (x OrderType) Enum() *OrderType {
	p := new(OrderType)
	*p = x
	return p
}
func (x OrderType) String() string {
	return proto.EnumName(OrderType_name, int32(x))
}
func (x *OrderType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(OrderType_value, data, "OrderType")
	if err != nil {
		return err
	}
	*x = OrderType(value)
	return nil
}

type TimeInForce int32

const (
	TimeInForce_DAY                 TimeInForce = 0
	TimeInForce_GOOD_TILL_CANCEL    TimeInForce = 1
	TimeInForce_AT_THE_OPENING      TimeInForce = 2
	TimeInForce_IMMEDIATE_OR_CANCEL TimeInForce = 3
	TimeInForce_FILL_OR_KILL        TimeInForce = 4
	TimeInForce_GOOD_TILL_CROSSING  TimeInForce = 5
	TimeInForce_GOOD_TILL_DATE      TimeInForce = 6
	TimeInForce_AT_THE_CLOSE        TimeInForce = 7
)

var TimeInForce_name = map[int32]string{
	0: "DAY",
	1: "GOOD_TILL_CANCEL",
	2: "AT_THE_OPENING",
	3: "IMMEDIATE_OR_CANCEL",
	4: "FILL_OR_KILL",
	5: "GOOD_TILL_CROSSING",
	6: "GOOD_TILL_DATE",
	7: "AT_THE_CLOSE",
}
var TimeInForce_value = map[string]int32{
	"DAY":                 0,
	"GOOD_TILL_CANCEL":    1,
	"AT_THE_OPENING":      2,
	"IMMEDIATE_OR_CANCEL": 3,
	"FILL_OR_KILL":        4,
	"GOOD_TILL_CROSSING":  5,
	"GOOD_TILL_DATE":      6,
	"AT_THE_CLOSE":        7,
}

func (x TimeInForce) Enum() *TimeInForce {
	p := new(TimeInForce)
	*p = x
	return p
}
func (x TimeInForce) String() string {
	return proto.EnumName(TimeInForce_name, int32(x))
}
func (x *TimeInForce) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(TimeInForce_value, data, "TimeInForce")
	if err != nil {
		return err
	}
	*x = TimeInForce(value)
	return nil
}

type HandlInst int32

const (
	HandlInst_UNKNOWN_HANDL_INST                HandlInst = 0
	HandlInst_AUTOMATED_EXECUTION_ORDER_PRIVATE HandlInst = 1
	HandlInst_AUTOMATED_EXECUTION_ORDER_PUBLIC  HandlInst = 2
	HandlInst_MANUAL_ORDER                      HandlInst = 3
)

var HandlInst_name = map[int32]string{
	0: "UNKNOWN_HANDL_INST",
	1: "AUTOMATED_EXECUTION_ORDER_PRIVATE",
	2: "AUTOMATED_EXECUTION_ORDER_PUBLIC",
	3: "MANUAL_ORDER",
}
var HandlInst_value = map[string]int32{
	"UNKNOWN_HANDL_INST":                0,
	"AUTOMATED_EXECUTION_ORDER_PRIVATE": 1,
	"AUTOMATED_EXECUTION_ORDER_PUBLIC":  2,
	"MANUAL_ORDER":                      3,
}

func (x HandlInst) Enum() *HandlInst {
	p := new(HandlInst)
	*p = x
	return p
}
func (x HandlInst) String() string {
	return proto.EnumName(HandlInst_name, int32(x))
}
func (x *HandlInst) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HandlInst_value, data, "HandlInst")
	if err != nil {
		return err
	}
	*x = HandlInst(value)
	return nil
}

type LastLiquidityInd int32

const (
	LastLiquidityInd_UNKNOWN_LAST_LIQUIDITY_IND LastLiquidityInd = 0
	LastLiquidityInd_ADDED_LIQUIDITY            LastLiquidityInd = 1
	LastLiquidityInd_REMOVED_LIQUIDITY          LastLiquidityInd = 2
	LastLiquidityInd_LIQUIDITY_ROUTED_OUT       LastLiquidityInd = 3
	LastLiquidityInd_AUCTION                    LastLiquidityInd = 4
)

var LastLiquidityInd_name = map[int32]string{
	0: "UNKNOWN_LAST_LIQUIDITY_IND",
	1: "ADDED_LIQUIDITY",
	2: "REMOVED_LIQUIDITY",
	3: "LIQUIDITY_ROUTED_OUT",
	4: "AUCTION",
}
var LastLiquidityInd_value = map[string]int32{
	"UNKNOWN_LAST_LIQUIDITY_IND": 0,
	"ADDED_LIQUIDITY":            1,
	"REMOVED_LIQUIDITY":          2,
	"LIQUIDITY_ROUTED_OUT":       3,
	"AUCTION":                    4,
}

func (x LastLiquidityInd) Enum() *LastLiquidityInd {
	p := new(LastLiquidityInd)
	*p = x
	return p
}
func (x LastLiquidityInd) String() string {
	return proto.EnumName(LastLiquidityInd_name, int32(x))
}
func (x *LastLiquidityInd) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(LastLiquidityInd_value, data, "LastLiquidityInd")
	if err != nil {
		return err
	}
	*x = LastLiquidityInd(value)
	return nil
}

type Order_OrderMessageType int32

const (
	Order_NEW     Order_OrderMessageType = 0
	Order_CANCEL  Order_OrderMessageType = 1
	Order_REPLACE Order_OrderMessageType = 2
)

var Order_OrderMessageType_name = map[int32]string{
	0: "NEW",
	1: "CANCEL",
	2: "REPLACE",
}
var Order_OrderMessageType_value = map[string]int32{
	"NEW":     0,
	"CANCEL":  1,
	"REPLACE": 2,
}

func (x Order_OrderMessageType) Enum() *Order_OrderMessageType {
	p := new(Order_OrderMessageType)
	*p = x
	return p
}
func (x Order_OrderMessageType) String() string {
	return proto.EnumName(Order_OrderMessageType_name, int32(x))
}
func (x *Order_OrderMessageType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Order_OrderMessageType_value, data, "Order_OrderMessageType")
	if err != nil {
		return err
	}
	*x = Order_OrderMessageType(value)
	return nil
}

type Execution_ExecType int32

const (
	Execution_NEW             Execution_ExecType = 0
	Execution_PARTIAL_FILL    Execution_ExecType = 1
	Execution_FILL            Execution_ExecType = 2
	Execution_DONE_FOR_DAY    Execution_ExecType = 3
	Execution_CANCELED        Execution_ExecType = 4
	Execution_REPLACE         Execution_ExecType = 5
	Execution_PENDING_CANCEL  Execution_ExecType = 6
	Execution_STOPPED         Execution_ExecType = 7
	Execution_REJECTED        Execution_ExecType = 8
	Execution_SUSPENDED       Execution_ExecType = 9
	Execution_PENDING_NEW     Execution_ExecType = 10
	Execution_CALCULATED      Execution_ExecType = 11
	Execution_EXPIRED         Execution_ExecType = 12
	Execution_RESTATED        Execution_ExecType = 13
	Execution_PENDING_REPLACE Execution_ExecType = 14
	Execution_TRADE           Execution_ExecType = 15
	Execution_TRADE_CORRECT   Execution_ExecType = 16
	Execution_TRADE_CANCEL    Execution_ExecType = 17
	Execution_ORDER_STATUS    Execution_ExecType = 18
)

var Execution_ExecType_name = map[int32]string{
	0:  "NEW",
	1:  "PARTIAL_FILL",
	2:  "FILL",
	3:  "DONE_FOR_DAY",
	4:  "CANCELED",
	5:  "REPLACE",
	6:  "PENDING_CANCEL",
	7:  "STOPPED",
	8:  "REJECTED",
	9:  "SUSPENDED",
	10: "PENDING_NEW",
	11: "CALCULATED",
	12: "EXPIRED",
	13: "RESTATED",
	14: "PENDING_REPLACE",
	15: "TRADE",
	16: "TRADE_CORRECT",
	17: "TRADE_CANCEL",
	18: "ORDER_STATUS",
}
var Execution_ExecType_value = map[string]int32{
	"NEW":             0,
	"PARTIAL_FILL":    1,
	"FILL":            2,
	"DONE_FOR_DAY":    3,
	"CANCELED":        4,
	"REPLACE":         5,
	"PENDING_CANCEL":  6,
	"STOPPED":         7,
	"REJECTED":        8,
	"SUSPENDED":       9,
	"PENDING_NEW":     10,
	"CALCULATED":      11,
	"EXPIRED":         12,
	"RESTATED":        13,
	"PENDING_REPLACE": 14,
	"TRADE":           15,
	"TRADE_CORRECT":   16,
	"TRADE_CANCEL":    17,
	"ORDER_STATUS":    18,
}

func (x Execution_ExecType) Enum() *Execution_ExecType {
	p := new(Execution_ExecType)
	*p = x
	return p
}
func (x Execution_ExecType) String() string {
	return proto.EnumName(Execution_ExecType_name, int32(x))
}
func (x *Execution_ExecType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(Execution_ExecType_value, data, "Execution_ExecType")
	if err != nil {
		return err
	}
	*x = Execution_ExecType(value)
	return nil
}

type Order struct {
	// Idents
	ClientGuid  string                 `protobuf:"bytes,1,req,name=client_guid" json:"client_guid"`
	OrderId     int32                  `protobuf:"varint,2,req,name=order_id" json:"order_id"`
	OrderKey    int32                  `protobuf:"varint,3,req,name=order_key" json:"order_key"`
	Version     int32                  `protobuf:"varint,4,req,name=version" json:"version"`
	MessageType Order_OrderMessageType `protobuf:"varint,5,opt,name=message_type,enum=proto.order.Order_OrderMessageType" json:"message_type"`
	// basic
	Side     Side    `protobuf:"varint,6,req,name=side,enum=proto.order.Side" json:"side"`
	Quantity float64 `protobuf:"fixed64,7,req,name=quantity" json:"quantity"`
	Symbol   string  `protobuf:"bytes,8,req,name=symbol" json:"symbol"`
	// execution specific
	OrderType      OrderType   `protobuf:"varint,16,req,name=order_type,enum=proto.order.OrderType" json:"order_type"`
	Timeinforce    TimeInForce `protobuf:"varint,17,req,name=timeinforce,enum=proto.order.TimeInForce" json:"timeinforce"`
	LimitPrice     float64     `protobuf:"fixed64,18,opt,name=limit_price" json:"limit_price"`
	Exchange       string      `protobuf:"bytes,19,opt,name=exchange" json:"exchange"`
	Description    string      `protobuf:"bytes,20,opt,name=description" json:"description"`
	FilledQuantity float64     `protobuf:"fixed64,21,opt,name=filled_quantity" json:"filled_quantity"`
	FilledAvgPrice float64     `protobuf:"fixed64,22,opt,name=filled_avg_price" json:"filled_avg_price"`
	OrderStatus    OrderStatus `protobuf:"varint,23,opt,name=order_status,enum=proto.order.OrderStatus" json:"order_status"`
	// accounts
	AccountId       int32  `protobuf:"varint,30,req,name=account_id" json:"account_id"`
	BrokerUserid    string `protobuf:"bytes,31,opt,name=broker_userid" json:"broker_userid"`
	BrokerAccount   string `protobuf:"bytes,32,opt,name=broker_account" json:"broker_account"`
	MarketConnector string `protobuf:"bytes,33,opt,name=market_connector" json:"market_connector"`
	// execution extra
	SettlCcy       string    `protobuf:"bytes,40,opt,name=settl_ccy" json:"settl_ccy"`
	HandleInst     HandlInst `protobuf:"varint,41,req,name=handle_inst,enum=proto.order.HandlInst" json:"handle_inst"`
	Algo           string    `protobuf:"bytes,42,opt,name=algo" json:"algo"`
	IsComplete     bool      `protobuf:"varint,43,opt,name=is_complete" json:"is_complete"`
	IsBooked       bool      `protobuf:"varint,44,opt,name=is_booked" json:"is_booked"`
	IsExpired      bool      `protobuf:"varint,45,opt,name=is_expired" json:"is_expired"`
	TradeBookingId int32     `protobuf:"varint,46,opt,name=trade_booking_id" json:"trade_booking_id"`
	OpenClose      string    `protobuf:"bytes,47,opt,name=open_close" json:"open_close"`
	// source
	Source   string `protobuf:"bytes,50,opt,name=source" json:"source"`
	Trader   string `protobuf:"bytes,51,opt,name=trader" json:"trader"`
	TraderId int32  `protobuf:"varint,52,req,name=trader_id" json:"trader_id"`
	Machine  string `protobuf:"bytes,53,opt,name=machine" json:"machine"`
	Memo     string `protobuf:"bytes,54,opt,name=memo" json:"memo"`
	// timing
	CreateDatetime string `protobuf:"bytes,60,opt,name=create_datetime" json:"create_datetime"`
	SubmitDatetime string `protobuf:"bytes,61,opt,name=submit_datetime" json:"submit_datetime"`
	// array components
	Executions       []Execution  `protobuf:"bytes,70,rep,name=executions" json:"executions"`
	Allocations      []Allocation `protobuf:"bytes,80,rep,name=allocations" json:"allocations"`
	XXX_unrecognized []byte       `json:"-"`
}

func (m *Order) Reset()      { *m = Order{} }
func (*Order) ProtoMessage() {}

func (m *Order) GetClientGuid() string {
	if m != nil {
		return m.ClientGuid
	}
	return ""
}

func (m *Order) GetOrderId() int32 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *Order) GetOrderKey() int32 {
	if m != nil {
		return m.OrderKey
	}
	return 0
}

func (m *Order) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *Order) GetMessageType() Order_OrderMessageType {
	if m != nil {
		return m.MessageType
	}
	return Order_NEW
}

func (m *Order) GetSide() Side {
	if m != nil {
		return m.Side
	}
	return Side_UNKNOWN_SIDE
}

func (m *Order) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Order) GetSymbol() string {
	if m != nil {
		return m.Symbol
	}
	return ""
}

func (m *Order) GetOrderType() OrderType {
	if m != nil {
		return m.OrderType
	}
	return OrderType_UNKNOWN_ORDER_TYPE
}

func (m *Order) GetTimeinforce() TimeInForce {
	if m != nil {
		return m.Timeinforce
	}
	return TimeInForce_DAY
}

func (m *Order) GetLimitPrice() float64 {
	if m != nil {
		return m.LimitPrice
	}
	return 0
}

func (m *Order) GetExchange() string {
	if m != nil {
		return m.Exchange
	}
	return ""
}

func (m *Order) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

func (m *Order) GetFilledQuantity() float64 {
	if m != nil {
		return m.FilledQuantity
	}
	return 0
}

func (m *Order) GetFilledAvgPrice() float64 {
	if m != nil {
		return m.FilledAvgPrice
	}
	return 0
}

func (m *Order) GetOrderStatus() OrderStatus {
	if m != nil {
		return m.OrderStatus
	}
	return OrderStatus_NEW
}

func (m *Order) GetAccountId() int32 {
	if m != nil {
		return m.AccountId
	}
	return 0
}

func (m *Order) GetBrokerUserid() string {
	if m != nil {
		return m.BrokerUserid
	}
	return ""
}

func (m *Order) GetBrokerAccount() string {
	if m != nil {
		return m.BrokerAccount
	}
	return ""
}

func (m *Order) GetMarketConnector() string {
	if m != nil {
		return m.MarketConnector
	}
	return ""
}

func (m *Order) GetSettlCcy() string {
	if m != nil {
		return m.SettlCcy
	}
	return ""
}

func (m *Order) GetHandleInst() HandlInst {
	if m != nil {
		return m.HandleInst
	}
	return HandlInst_UNKNOWN_HANDL_INST
}

func (m *Order) GetAlgo() string {
	if m != nil {
		return m.Algo
	}
	return ""
}

func (m *Order) GetIsComplete() bool {
	if m != nil {
		return m.IsComplete
	}
	return false
}

func (m *Order) GetIsBooked() bool {
	if m != nil {
		return m.IsBooked
	}
	return false
}

func (m *Order) GetIsExpired() bool {
	if m != nil {
		return m.IsExpired
	}
	return false
}

func (m *Order) GetTradeBookingId() int32 {
	if m != nil {
		return m.TradeBookingId
	}
	return 0
}

func (m *Order) GetOpenClose() string {
	if m != nil {
		return m.OpenClose
	}
	return ""
}

func (m *Order) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *Order) GetTrader() string {
	if m != nil {
		return m.Trader
	}
	return ""
}

func (m *Order) GetTraderId() int32 {
	if m != nil {
		return m.TraderId
	}
	return 0
}

func (m *Order) GetMachine() string {
	if m != nil {
		return m.Machine
	}
	return ""
}

func (m *Order) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *Order) GetCreateDatetime() string {
	if m != nil {
		return m.CreateDatetime
	}
	return ""
}

func (m *Order) GetSubmitDatetime() string {
	if m != nil {
		return m.SubmitDatetime
	}
	return ""
}

func (m *Order) GetExecutions() []Execution {
	if m != nil {
		return m.Executions
	}
	return nil
}

func (m *Order) GetAllocations() []Allocation {
	if m != nil {
		return m.Allocations
	}
	return nil
}

type Execution struct {
	ExecutionId                  int32              `protobuf:"varint,1,req,name=execution_id" json:"execution_id"`
	OrderId                      int32              `protobuf:"varint,2,req,name=order_id" json:"order_id"`
	OrderKey                     int32              `protobuf:"varint,3,opt,name=order_key" json:"order_key"`
	ClientOrderId                string             `protobuf:"bytes,5,opt,name=client_order_id" json:"client_order_id"`
	BrokerOrderId                string             `protobuf:"bytes,6,opt,name=broker_order_id" json:"broker_order_id"`
	BrokerExecId                 string             `protobuf:"bytes,7,opt,name=broker_exec_id" json:"broker_exec_id"`
	PrevBrokerExecId             string             `protobuf:"bytes,8,opt,name=prev_broker_exec_id" json:"prev_broker_exec_id"`
	CancelReplaceByExececutionId int32              `protobuf:"varint,9,opt,name=cancel_replace_by_exececution_id" json:"cancel_replace_by_exececution_id"`
	OrderStatus                  OrderStatus        `protobuf:"varint,10,opt,name=order_status,enum=proto.order.OrderStatus" json:"order_status"`
	ExecType                     Execution_ExecType `protobuf:"varint,11,opt,name=exec_type,enum=proto.order.Execution_ExecType" json:"exec_type"`
	Quantity                     float64            `protobuf:"fixed64,20,opt,name=quantity" json:"quantity"`
	Price                        float64            `protobuf:"fixed64,21,opt,name=price" json:"price"`
	Text                         string             `protobuf:"bytes,30,opt,name=text" json:"text"`
	Lastmkt                      string             `protobuf:"bytes,31,opt,name=lastmkt" json:"lastmkt"`
	ExecBroker                   string             `protobuf:"bytes,32,opt,name=exec_broker" json:"exec_broker"`
	LastLiquidity                LastLiquidityInd   `protobuf:"varint,33,opt,name=last_liquidity,enum=proto.order.LastLiquidityInd" json:"last_liquidity"`
	CumQuantity                  float64            `protobuf:"fixed64,50,opt,name=cum_quantity" json:"cum_quantity"`
	AvgPrice                     float64            `protobuf:"fixed64,51,opt,name=avg_price" json:"avg_price"`
	CalcCumQuantity              float64            `protobuf:"fixed64,52,opt,name=calc_cum_quantity" json:"calc_cum_quantity"`
	CalcAvgPrice                 float64            `protobuf:"fixed64,53,opt,name=calc_avg_price" json:"calc_avg_price"`
	// timing
	BrokerExecDatetime string `protobuf:"bytes,60,opt,name=broker_exec_datetime" json:"broker_exec_datetime"`
	CreateDatetime     string `protobuf:"bytes,61,opt,name=create_datetime" json:"create_datetime"`
	XXX_unrecognized   []byte `json:"-"`
}

func (m *Execution) Reset()      { *m = Execution{} }
func (*Execution) ProtoMessage() {}

func (m *Execution) GetExecutionId() int32 {
	if m != nil {
		return m.ExecutionId
	}
	return 0
}

func (m *Execution) GetOrderId() int32 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *Execution) GetOrderKey() int32 {
	if m != nil {
		return m.OrderKey
	}
	return 0
}

func (m *Execution) GetClientOrderId() string {
	if m != nil {
		return m.ClientOrderId
	}
	return ""
}

func (m *Execution) GetBrokerOrderId() string {
	if m != nil {
		return m.BrokerOrderId
	}
	return ""
}

func (m *Execution) GetBrokerExecId() string {
	if m != nil {
		return m.BrokerExecId
	}
	return ""
}

func (m *Execution) GetPrevBrokerExecId() string {
	if m != nil {
		return m.PrevBrokerExecId
	}
	return ""
}

func (m *Execution) GetCancelReplaceByExececutionId() int32 {
	if m != nil {
		return m.CancelReplaceByExececutionId
	}
	return 0
}

func (m *Execution) GetOrderStatus() OrderStatus {
	if m != nil {
		return m.OrderStatus
	}
	return OrderStatus_NEW
}

func (m *Execution) GetExecType() Execution_ExecType {
	if m != nil {
		return m.ExecType
	}
	return Execution_NEW
}

func (m *Execution) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Execution) GetPrice() float64 {
	if m != nil {
		return m.Price
	}
	return 0
}

func (m *Execution) GetText() string {
	if m != nil {
		return m.Text
	}
	return ""
}

func (m *Execution) GetLastmkt() string {
	if m != nil {
		return m.Lastmkt
	}
	return ""
}

func (m *Execution) GetExecBroker() string {
	if m != nil {
		return m.ExecBroker
	}
	return ""
}

func (m *Execution) GetLastLiquidity() LastLiquidityInd {
	if m != nil {
		return m.LastLiquidity
	}
	return LastLiquidityInd_UNKNOWN_LAST_LIQUIDITY_IND
}

func (m *Execution) GetCumQuantity() float64 {
	if m != nil {
		return m.CumQuantity
	}
	return 0
}

func (m *Execution) GetAvgPrice() float64 {
	if m != nil {
		return m.AvgPrice
	}
	return 0
}

func (m *Execution) GetCalcCumQuantity() float64 {
	if m != nil {
		return m.CalcCumQuantity
	}
	return 0
}

func (m *Execution) GetCalcAvgPrice() float64 {
	if m != nil {
		return m.CalcAvgPrice
	}
	return 0
}

func (m *Execution) GetBrokerExecDatetime() string {
	if m != nil {
		return m.BrokerExecDatetime
	}
	return ""
}

func (m *Execution) GetCreateDatetime() string {
	if m != nil {
		return m.CreateDatetime
	}
	return ""
}

type Allocation struct {
	AllocationId     int32   `protobuf:"varint,1,opt,name=allocation_id" json:"allocation_id"`
	OrderKey         int32   `protobuf:"varint,2,opt,name=order_key" json:"order_key"`
	StrategyId       int32   `protobuf:"varint,3,opt,name=strategy_id" json:"strategy_id"`
	Quantity         float64 `protobuf:"fixed64,10,opt,name=quantity" json:"quantity"`
	Ratio            float64 `protobuf:"fixed64,11,opt,name=ratio" json:"ratio"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *Allocation) Reset()      { *m = Allocation{} }
func (*Allocation) ProtoMessage() {}

func (m *Allocation) GetAllocationId() int32 {
	if m != nil {
		return m.AllocationId
	}
	return 0
}

func (m *Allocation) GetOrderKey() int32 {
	if m != nil {
		return m.OrderKey
	}
	return 0
}

func (m *Allocation) GetStrategyId() int32 {
	if m != nil {
		return m.StrategyId
	}
	return 0
}

func (m *Allocation) GetQuantity() float64 {
	if m != nil {
		return m.Quantity
	}
	return 0
}

func (m *Allocation) GetRatio() float64 {
	if m != nil {
		return m.Ratio
	}
	return 0
}

type NewOrderRequest struct {
	Order            *Order `protobuf:"bytes,1,opt,name=order" json:"order,omitempty"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *NewOrderRequest) Reset()      { *m = NewOrderRequest{} }
func (*NewOrderRequest) ProtoMessage() {}

func (m *NewOrderRequest) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

type NewOrderResponse struct {
	ErrorCode        int32   `protobuf:"varint,1,opt,name=error_code" json:"error_code"`
	ErrorMessage     *string `protobuf:"bytes,2,opt,name=error_message" json:"error_message,omitempty"`
	Order            *Order  `protobuf:"bytes,10,opt,name=order" json:"order,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *NewOrderResponse) Reset()      { *m = NewOrderResponse{} }
func (*NewOrderResponse) ProtoMessage() {}

func (m *NewOrderResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *NewOrderResponse) GetErrorMessage() string {
	if m != nil && m.ErrorMessage != nil {
		return *m.ErrorMessage
	}
	return ""
}

func (m *NewOrderResponse) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

type CancelOrderRequest struct {
	ClientGuid       string `protobuf:"bytes,1,opt,name=client_guid" json:"client_guid"`
	OrderId          int32  `protobuf:"varint,2,req,name=order_id" json:"order_id"`
	OrderKey         int32  `protobuf:"varint,3,opt,name=order_key" json:"order_key"`
	Version          int32  `protobuf:"varint,4,opt,name=version" json:"version"`
	Source           string `protobuf:"bytes,50,opt,name=source" json:"source"`
	Trader           string `protobuf:"bytes,51,opt,name=trader" json:"trader"`
	TraderId         int32  `protobuf:"varint,52,req,name=trader_id" json:"trader_id"`
	Machine          string `protobuf:"bytes,53,opt,name=machine" json:"machine"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *CancelOrderRequest) Reset()      { *m = CancelOrderRequest{} }
func (*CancelOrderRequest) ProtoMessage() {}

func (m *CancelOrderRequest) GetClientGuid() string {
	if m != nil {
		return m.ClientGuid
	}
	return ""
}

func (m *CancelOrderRequest) GetOrderId() int32 {
	if m != nil {
		return m.OrderId
	}
	return 0
}

func (m *CancelOrderRequest) GetOrderKey() int32 {
	if m != nil {
		return m.OrderKey
	}
	return 0
}

func (m *CancelOrderRequest) GetVersion() int32 {
	if m != nil {
		return m.Version
	}
	return 0
}

func (m *CancelOrderRequest) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *CancelOrderRequest) GetTrader() string {
	if m != nil {
		return m.Trader
	}
	return ""
}

func (m *CancelOrderRequest) GetTraderId() int32 {
	if m != nil {
		return m.TraderId
	}
	return 0
}

func (m *CancelOrderRequest) GetMachine() string {
	if m != nil {
		return m.Machine
	}
	return ""
}

type CancelOrderResponse struct {
	ErrorCode        int32   `protobuf:"varint,1,opt,name=error_code" json:"error_code"`
	ErrorMessage     *string `protobuf:"bytes,2,opt,name=error_message" json:"error_message,omitempty"`
	Order            *Order  `protobuf:"bytes,10,opt,name=order" json:"order,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *CancelOrderResponse) Reset()      { *m = CancelOrderResponse{} }
func (*CancelOrderResponse) ProtoMessage() {}

func (m *CancelOrderResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *CancelOrderResponse) GetErrorMessage() string {
	if m != nil && m.ErrorMessage != nil {
		return *m.ErrorMessage
	}
	return ""
}

func (m *CancelOrderResponse) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

type ReplaceOrderRequest struct {
	Order            *Order `protobuf:"bytes,1,opt,name=order" json:"order,omitempty"`
	Source           string `protobuf:"bytes,50,opt,name=source" json:"source"`
	Trader           string `protobuf:"bytes,51,opt,name=trader" json:"trader"`
	TraderId         int32  `protobuf:"varint,52,req,name=trader_id" json:"trader_id"`
	Machine          string `protobuf:"bytes,53,opt,name=machine" json:"machine"`
	XXX_unrecognized []byte `json:"-"`
}

func (m *ReplaceOrderRequest) Reset()      { *m = ReplaceOrderRequest{} }
func (*ReplaceOrderRequest) ProtoMessage() {}

func (m *ReplaceOrderRequest) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func (m *ReplaceOrderRequest) GetSource() string {
	if m != nil {
		return m.Source
	}
	return ""
}

func (m *ReplaceOrderRequest) GetTrader() string {
	if m != nil {
		return m.Trader
	}
	return ""
}

func (m *ReplaceOrderRequest) GetTraderId() int32 {
	if m != nil {
		return m.TraderId
	}
	return 0
}

func (m *ReplaceOrderRequest) GetMachine() string {
	if m != nil {
		return m.Machine
	}
	return ""
}

type ReplaceOrderResponse struct {
	ErrorCode        int32   `protobuf:"varint,1,opt,name=error_code" json:"error_code"`
	ErrorMessage     *string `protobuf:"bytes,2,opt,name=error_message" json:"error_message,omitempty"`
	Order            *Order  `protobuf:"bytes,10,opt,name=order" json:"order,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ReplaceOrderResponse) Reset()      { *m = ReplaceOrderResponse{} }
func (*ReplaceOrderResponse) ProtoMessage() {}

func (m *ReplaceOrderResponse) GetErrorCode() int32 {
	if m != nil {
		return m.ErrorCode
	}
	return 0
}

func (m *ReplaceOrderResponse) GetErrorMessage() string {
	if m != nil && m.ErrorMessage != nil {
		return *m.ErrorMessage
	}
	return ""
}

func (m *ReplaceOrderResponse) GetOrder() *Order {
	if m != nil {
		return m.Order
	}
	return nil
}

func init() {
	proto.RegisterEnum("proto.order.OrderStatus", OrderStatus_name, OrderStatus_value)
	proto.RegisterEnum("proto.order.Side", Side_name, Side_value)
	proto.RegisterEnum("proto.order.OrderType", OrderType_name, OrderType_value)
	proto.RegisterEnum("proto.order.TimeInForce", TimeInForce_name, TimeInForce_value)
	proto.RegisterEnum("proto.order.HandlInst", HandlInst_name, HandlInst_value)
	proto.RegisterEnum("proto.order.LastLiquidityInd", LastLiquidityInd_name, LastLiquidityInd_value)
	proto.RegisterEnum("proto.order.Order_OrderMessageType", Order_OrderMessageType_name, Order_OrderMessageType_value)
	proto.RegisterEnum("proto.order.Execution_ExecType", Execution_ExecType_name, Execution_ExecType_value)
}
func (m *Order) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientGuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientGuid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderKey", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrderKey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000004)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000008)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MessageType", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.MessageType |= (Order_OrderMessageType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Side", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Side |= (Side(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000010)
		case 7:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Quantity = float64(math.Float64frombits(v))
			hasFields[0] |= uint64(0x00000020)
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Symbol", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Symbol = string(data[iNdEx:postIndex])
			iNdEx = postIndex
			hasFields[0] |= uint64(0x00000040)
		case 16:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderType", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrderType |= (OrderType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000080)
		case 17:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeinforce", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Timeinforce |= (TimeInForce(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000100)
		case 18:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field LimitPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.LimitPrice = float64(math.Float64frombits(v))
		case 19:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Exchange", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Exchange = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 20:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Description", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Description = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilledQuantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.FilledQuantity = float64(math.Float64frombits(v))
		case 22:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field FilledAvgPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.FilledAvgPrice = float64(math.Float64frombits(v))
		case 23:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderStatus", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrderStatus |= (OrderStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 30:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AccountId", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.AccountId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000200)
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerUserid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BrokerUserid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerAccount", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BrokerAccount = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MarketConnector", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MarketConnector = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 40:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SettlCcy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SettlCcy = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 41:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HandleInst", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.HandleInst |= (HandlInst(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000400)
		case 42:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Algo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Algo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 43:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsComplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsComplete = bool(v != 0)
		case 44:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsBooked", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsBooked = bool(v != 0)
		case 45:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IsExpired", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IsExpired = bool(v != 0)
		case 46:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TradeBookingId", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TradeBookingId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 47:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OpenClose", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OpenClose = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trader = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraderId", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TraderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000800)
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Machine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Machine = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 54:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Memo", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Memo = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDatetime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateDatetime = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SubmitDatetime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SubmitDatetime = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 70:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Executions", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Executions = append(m.Executions, Execution{})
			if err := m.Executions[len(m.Executions)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 80:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Allocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Allocations = append(m.Allocations, Allocation{})
			if err := m.Allocations[len(m.Allocations)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOrder(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("client_guid")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("order_id")
	}
	if hasFields[0]&uint64(0x00000004) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("order_key")
	}
	if hasFields[0]&uint64(0x00000008) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("version")
	}
	if hasFields[0]&uint64(0x00000010) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("side")
	}
	if hasFields[0]&uint64(0x00000020) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("quantity")
	}
	if hasFields[0]&uint64(0x00000040) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("symbol")
	}
	if hasFields[0]&uint64(0x00000080) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("order_type")
	}
	if hasFields[0]&uint64(0x00000100) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("timeinforce")
	}
	if hasFields[0]&uint64(0x00000200) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("account_id")
	}
	if hasFields[0]&uint64(0x00000400) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("handle_inst")
	}
	if hasFields[0]&uint64(0x00000800) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("trader_id")
	}

	return nil
}
func (m *Execution) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecutionId", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExecutionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderKey", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrderKey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientOrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientOrderId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerOrderId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BrokerOrderId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerExecId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BrokerExecId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrevBrokerExecId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrevBrokerExecId = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CancelReplaceByExececutionId", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.CancelReplaceByExececutionId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderStatus", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrderStatus |= (OrderStatus(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecType", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ExecType |= (Execution_ExecType(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 20:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Quantity = float64(math.Float64frombits(v))
		case 21:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Price", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Price = float64(math.Float64frombits(v))
		case 30:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 31:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Lastmkt", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Lastmkt = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 32:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExecBroker", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExecBroker = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 33:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastLiquidity", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LastLiquidity |= (LastLiquidityInd(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CumQuantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.CumQuantity = float64(math.Float64frombits(v))
		case 51:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field AvgPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.AvgPrice = float64(math.Float64frombits(v))
		case 52:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalcCumQuantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.CalcCumQuantity = float64(math.Float64frombits(v))
		case 53:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field CalcAvgPrice", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.CalcAvgPrice = float64(math.Float64frombits(v))
		case 60:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field BrokerExecDatetime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.BrokerExecDatetime = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 61:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreateDatetime", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CreateDatetime = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOrder(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("execution_id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("order_id")
	}

	return nil
}
func (m *Allocation) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AllocationId", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.AllocationId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderKey", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrderKey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StrategyId", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StrategyId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Quantity = float64(math.Float64frombits(v))
		case 11:
			if wireType != 1 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ratio", wireType)
			}
			var v uint64
			if (iNdEx + 8) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += 8
			v = uint64(data[iNdEx-8])
			v |= uint64(data[iNdEx-7]) << 8
			v |= uint64(data[iNdEx-6]) << 16
			v |= uint64(data[iNdEx-5]) << 24
			v |= uint64(data[iNdEx-4]) << 32
			v |= uint64(data[iNdEx-3]) << 40
			v |= uint64(data[iNdEx-2]) << 48
			v |= uint64(data[iNdEx-1]) << 56
			m.Ratio = float64(math.Float64frombits(v))
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOrder(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NewOrderRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &Order{}
			}
			if err := m.Order.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOrder(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *NewOrderResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ErrorMessage = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &Order{}
			}
			if err := m.Order.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOrder(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *CancelOrderRequest) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientGuid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClientGuid = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderId", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field OrderKey", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.OrderKey |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Version", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Version |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trader = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraderId", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TraderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000002)
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Machine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Machine = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOrder(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("order_id")
	}
	if hasFields[0]&uint64(0x00000002) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("trader_id")
	}

	return nil
}
func (m *CancelOrderResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ErrorMessage = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &Order{}
			}
			if err := m.Order.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOrder(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func (m *ReplaceOrderRequest) Unmarshal(data []byte) error {
	var hasFields [1]uint64
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &Order{}
			}
			if err := m.Order.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 50:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Source = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 51:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Trader", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Trader = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 52:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TraderId", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TraderId |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			hasFields[0] |= uint64(0x00000001)
		case 53:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Machine", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Machine = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOrder(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}
	if hasFields[0]&uint64(0x00000001) == 0 {
		return github_com_gogo_protobuf_proto.NewRequiredNotSetError("trader_id")
	}

	return nil
}
func (m *ReplaceOrderResponse) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorCode", wireType)
			}
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ErrorCode |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ErrorMessage", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + int(stringLen)
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			s := string(data[iNdEx:postIndex])
			m.ErrorMessage = &s
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Order", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Order == nil {
				m.Order = &Order{}
			}
			if err := m.Order.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			var sizeOfWire int
			for {
				sizeOfWire++
				wire >>= 7
				if wire == 0 {
					break
				}
			}
			iNdEx -= sizeOfWire
			skippy, err := skipOrder(data[iNdEx:])
			if err != nil {
				return err
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, data[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	return nil
}
func skipOrder(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipOrder(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}
func (this *Order) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Order{`,
		`ClientGuid:` + fmt.Sprintf("%v", this.ClientGuid) + `,`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`OrderKey:` + fmt.Sprintf("%v", this.OrderKey) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`MessageType:` + fmt.Sprintf("%v", this.MessageType) + `,`,
		`Side:` + fmt.Sprintf("%v", this.Side) + `,`,
		`Quantity:` + fmt.Sprintf("%v", this.Quantity) + `,`,
		`Symbol:` + fmt.Sprintf("%v", this.Symbol) + `,`,
		`OrderType:` + fmt.Sprintf("%v", this.OrderType) + `,`,
		`Timeinforce:` + fmt.Sprintf("%v", this.Timeinforce) + `,`,
		`LimitPrice:` + fmt.Sprintf("%v", this.LimitPrice) + `,`,
		`Exchange:` + fmt.Sprintf("%v", this.Exchange) + `,`,
		`Description:` + fmt.Sprintf("%v", this.Description) + `,`,
		`FilledQuantity:` + fmt.Sprintf("%v", this.FilledQuantity) + `,`,
		`FilledAvgPrice:` + fmt.Sprintf("%v", this.FilledAvgPrice) + `,`,
		`OrderStatus:` + fmt.Sprintf("%v", this.OrderStatus) + `,`,
		`AccountId:` + fmt.Sprintf("%v", this.AccountId) + `,`,
		`BrokerUserid:` + fmt.Sprintf("%v", this.BrokerUserid) + `,`,
		`BrokerAccount:` + fmt.Sprintf("%v", this.BrokerAccount) + `,`,
		`MarketConnector:` + fmt.Sprintf("%v", this.MarketConnector) + `,`,
		`SettlCcy:` + fmt.Sprintf("%v", this.SettlCcy) + `,`,
		`HandleInst:` + fmt.Sprintf("%v", this.HandleInst) + `,`,
		`Algo:` + fmt.Sprintf("%v", this.Algo) + `,`,
		`IsComplete:` + fmt.Sprintf("%v", this.IsComplete) + `,`,
		`IsBooked:` + fmt.Sprintf("%v", this.IsBooked) + `,`,
		`IsExpired:` + fmt.Sprintf("%v", this.IsExpired) + `,`,
		`TradeBookingId:` + fmt.Sprintf("%v", this.TradeBookingId) + `,`,
		`OpenClose:` + fmt.Sprintf("%v", this.OpenClose) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`Trader:` + fmt.Sprintf("%v", this.Trader) + `,`,
		`TraderId:` + fmt.Sprintf("%v", this.TraderId) + `,`,
		`Machine:` + fmt.Sprintf("%v", this.Machine) + `,`,
		`Memo:` + fmt.Sprintf("%v", this.Memo) + `,`,
		`CreateDatetime:` + fmt.Sprintf("%v", this.CreateDatetime) + `,`,
		`SubmitDatetime:` + fmt.Sprintf("%v", this.SubmitDatetime) + `,`,
		`Executions:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Executions), "Execution", "Execution", 1), `&`, ``, 1) + `,`,
		`Allocations:` + strings.Replace(strings.Replace(fmt.Sprintf("%v", this.Allocations), "Allocation", "Allocation", 1), `&`, ``, 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Execution) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Execution{`,
		`ExecutionId:` + fmt.Sprintf("%v", this.ExecutionId) + `,`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`OrderKey:` + fmt.Sprintf("%v", this.OrderKey) + `,`,
		`ClientOrderId:` + fmt.Sprintf("%v", this.ClientOrderId) + `,`,
		`BrokerOrderId:` + fmt.Sprintf("%v", this.BrokerOrderId) + `,`,
		`BrokerExecId:` + fmt.Sprintf("%v", this.BrokerExecId) + `,`,
		`PrevBrokerExecId:` + fmt.Sprintf("%v", this.PrevBrokerExecId) + `,`,
		`CancelReplaceByExececutionId:` + fmt.Sprintf("%v", this.CancelReplaceByExececutionId) + `,`,
		`OrderStatus:` + fmt.Sprintf("%v", this.OrderStatus) + `,`,
		`ExecType:` + fmt.Sprintf("%v", this.ExecType) + `,`,
		`Quantity:` + fmt.Sprintf("%v", this.Quantity) + `,`,
		`Price:` + fmt.Sprintf("%v", this.Price) + `,`,
		`Text:` + fmt.Sprintf("%v", this.Text) + `,`,
		`Lastmkt:` + fmt.Sprintf("%v", this.Lastmkt) + `,`,
		`ExecBroker:` + fmt.Sprintf("%v", this.ExecBroker) + `,`,
		`LastLiquidity:` + fmt.Sprintf("%v", this.LastLiquidity) + `,`,
		`CumQuantity:` + fmt.Sprintf("%v", this.CumQuantity) + `,`,
		`AvgPrice:` + fmt.Sprintf("%v", this.AvgPrice) + `,`,
		`CalcCumQuantity:` + fmt.Sprintf("%v", this.CalcCumQuantity) + `,`,
		`CalcAvgPrice:` + fmt.Sprintf("%v", this.CalcAvgPrice) + `,`,
		`BrokerExecDatetime:` + fmt.Sprintf("%v", this.BrokerExecDatetime) + `,`,
		`CreateDatetime:` + fmt.Sprintf("%v", this.CreateDatetime) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *Allocation) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&Allocation{`,
		`AllocationId:` + fmt.Sprintf("%v", this.AllocationId) + `,`,
		`OrderKey:` + fmt.Sprintf("%v", this.OrderKey) + `,`,
		`StrategyId:` + fmt.Sprintf("%v", this.StrategyId) + `,`,
		`Quantity:` + fmt.Sprintf("%v", this.Quantity) + `,`,
		`Ratio:` + fmt.Sprintf("%v", this.Ratio) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NewOrderRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NewOrderRequest{`,
		`Order:` + strings.Replace(fmt.Sprintf("%v", this.Order), "Order", "Order", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *NewOrderResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&NewOrderResponse{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`ErrorMessage:` + valueToStringOrder(this.ErrorMessage) + `,`,
		`Order:` + strings.Replace(fmt.Sprintf("%v", this.Order), "Order", "Order", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CancelOrderRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CancelOrderRequest{`,
		`ClientGuid:` + fmt.Sprintf("%v", this.ClientGuid) + `,`,
		`OrderId:` + fmt.Sprintf("%v", this.OrderId) + `,`,
		`OrderKey:` + fmt.Sprintf("%v", this.OrderKey) + `,`,
		`Version:` + fmt.Sprintf("%v", this.Version) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`Trader:` + fmt.Sprintf("%v", this.Trader) + `,`,
		`TraderId:` + fmt.Sprintf("%v", this.TraderId) + `,`,
		`Machine:` + fmt.Sprintf("%v", this.Machine) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *CancelOrderResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&CancelOrderResponse{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`ErrorMessage:` + valueToStringOrder(this.ErrorMessage) + `,`,
		`Order:` + strings.Replace(fmt.Sprintf("%v", this.Order), "Order", "Order", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceOrderRequest) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceOrderRequest{`,
		`Order:` + strings.Replace(fmt.Sprintf("%v", this.Order), "Order", "Order", 1) + `,`,
		`Source:` + fmt.Sprintf("%v", this.Source) + `,`,
		`Trader:` + fmt.Sprintf("%v", this.Trader) + `,`,
		`TraderId:` + fmt.Sprintf("%v", this.TraderId) + `,`,
		`Machine:` + fmt.Sprintf("%v", this.Machine) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func (this *ReplaceOrderResponse) String() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&ReplaceOrderResponse{`,
		`ErrorCode:` + fmt.Sprintf("%v", this.ErrorCode) + `,`,
		`ErrorMessage:` + valueToStringOrder(this.ErrorMessage) + `,`,
		`Order:` + strings.Replace(fmt.Sprintf("%v", this.Order), "Order", "Order", 1) + `,`,
		`XXX_unrecognized:` + fmt.Sprintf("%v", this.XXX_unrecognized) + `,`,
		`}`,
	}, "")
	return s
}
func valueToStringOrder(v interface{}) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("*%v", pv)
}
func (m *Order) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientGuid)
	n += 1 + l + sovOrder(uint64(l))
	n += 1 + sovOrder(uint64(m.OrderId))
	n += 1 + sovOrder(uint64(m.OrderKey))
	n += 1 + sovOrder(uint64(m.Version))
	n += 1 + sovOrder(uint64(m.MessageType))
	n += 1 + sovOrder(uint64(m.Side))
	n += 9
	l = len(m.Symbol)
	n += 1 + l + sovOrder(uint64(l))
	n += 2 + sovOrder(uint64(m.OrderType))
	n += 2 + sovOrder(uint64(m.Timeinforce))
	n += 10
	l = len(m.Exchange)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.Description)
	n += 2 + l + sovOrder(uint64(l))
	n += 10
	n += 10
	n += 2 + sovOrder(uint64(m.OrderStatus))
	n += 2 + sovOrder(uint64(m.AccountId))
	l = len(m.BrokerUserid)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.BrokerAccount)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.MarketConnector)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.SettlCcy)
	n += 2 + l + sovOrder(uint64(l))
	n += 2 + sovOrder(uint64(m.HandleInst))
	l = len(m.Algo)
	n += 2 + l + sovOrder(uint64(l))
	n += 3
	n += 3
	n += 3
	n += 2 + sovOrder(uint64(m.TradeBookingId))
	l = len(m.OpenClose)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.Source)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.Trader)
	n += 2 + l + sovOrder(uint64(l))
	n += 2 + sovOrder(uint64(m.TraderId))
	l = len(m.Machine)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.Memo)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.CreateDatetime)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.SubmitDatetime)
	n += 2 + l + sovOrder(uint64(l))
	if len(m.Executions) > 0 {
		for _, e := range m.Executions {
			l = e.Size()
			n += 2 + l + sovOrder(uint64(l))
		}
	}
	if len(m.Allocations) > 0 {
		for _, e := range m.Allocations {
			l = e.Size()
			n += 2 + l + sovOrder(uint64(l))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Execution) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOrder(uint64(m.ExecutionId))
	n += 1 + sovOrder(uint64(m.OrderId))
	n += 1 + sovOrder(uint64(m.OrderKey))
	l = len(m.ClientOrderId)
	n += 1 + l + sovOrder(uint64(l))
	l = len(m.BrokerOrderId)
	n += 1 + l + sovOrder(uint64(l))
	l = len(m.BrokerExecId)
	n += 1 + l + sovOrder(uint64(l))
	l = len(m.PrevBrokerExecId)
	n += 1 + l + sovOrder(uint64(l))
	n += 1 + sovOrder(uint64(m.CancelReplaceByExececutionId))
	n += 1 + sovOrder(uint64(m.OrderStatus))
	n += 1 + sovOrder(uint64(m.ExecType))
	n += 10
	n += 10
	l = len(m.Text)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.Lastmkt)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.ExecBroker)
	n += 2 + l + sovOrder(uint64(l))
	n += 2 + sovOrder(uint64(m.LastLiquidity))
	n += 10
	n += 10
	n += 10
	n += 10
	l = len(m.BrokerExecDatetime)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.CreateDatetime)
	n += 2 + l + sovOrder(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Allocation) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOrder(uint64(m.AllocationId))
	n += 1 + sovOrder(uint64(m.OrderKey))
	n += 1 + sovOrder(uint64(m.StrategyId))
	n += 9
	n += 9
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewOrderRequest) Size() (n int) {
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *NewOrderResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOrder(uint64(m.ErrorCode))
	if m.ErrorMessage != nil {
		l = len(*m.ErrorMessage)
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelOrderRequest) Size() (n int) {
	var l int
	_ = l
	l = len(m.ClientGuid)
	n += 1 + l + sovOrder(uint64(l))
	n += 1 + sovOrder(uint64(m.OrderId))
	n += 1 + sovOrder(uint64(m.OrderKey))
	n += 1 + sovOrder(uint64(m.Version))
	l = len(m.Source)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.Trader)
	n += 2 + l + sovOrder(uint64(l))
	n += 2 + sovOrder(uint64(m.TraderId))
	l = len(m.Machine)
	n += 2 + l + sovOrder(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *CancelOrderResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOrder(uint64(m.ErrorCode))
	if m.ErrorMessage != nil {
		l = len(*m.ErrorMessage)
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplaceOrderRequest) Size() (n int) {
	var l int
	_ = l
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	l = len(m.Source)
	n += 2 + l + sovOrder(uint64(l))
	l = len(m.Trader)
	n += 2 + l + sovOrder(uint64(l))
	n += 2 + sovOrder(uint64(m.TraderId))
	l = len(m.Machine)
	n += 2 + l + sovOrder(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ReplaceOrderResponse) Size() (n int) {
	var l int
	_ = l
	n += 1 + sovOrder(uint64(m.ErrorCode))
	if m.ErrorMessage != nil {
		l = len(*m.ErrorMessage)
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.Order != nil {
		l = m.Order.Size()
		n += 1 + l + sovOrder(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovOrder(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozOrder(x uint64) (n int) {
	return sovOrder(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func NewPopulatedOrder(r randyOrder, easy bool) *Order {
	this := &Order{}
	this.ClientGuid = randStringOrder(r)
	this.OrderId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.OrderId *= -1
	}
	this.OrderKey = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.OrderKey *= -1
	}
	this.Version = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Version *= -1
	}
	this.MessageType = Order_OrderMessageType([]int32{0, 1, 2}[r.Intn(3)])
	this.Side = Side([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16}[r.Intn(17)])
	this.Quantity = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Quantity *= -1
	}
	this.Symbol = randStringOrder(r)
	this.OrderType = OrderType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23}[r.Intn(24)])
	this.Timeinforce = TimeInForce([]int32{0, 1, 2, 3, 4, 5, 6, 7}[r.Intn(8)])
	this.LimitPrice = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.LimitPrice *= -1
	}
	this.Exchange = randStringOrder(r)
	this.Description = randStringOrder(r)
	this.FilledQuantity = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.FilledQuantity *= -1
	}
	this.FilledAvgPrice = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.FilledAvgPrice *= -1
	}
	this.OrderStatus = OrderStatus([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 100, 101, 102, 103, 110, 111, 112, 113, 120, 121, 122, 123, 125, 126, 130, 131, 132, 133, 134, 135}[r.Intn(35)])
	this.AccountId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.AccountId *= -1
	}
	this.BrokerUserid = randStringOrder(r)
	this.BrokerAccount = randStringOrder(r)
	this.MarketConnector = randStringOrder(r)
	this.SettlCcy = randStringOrder(r)
	this.HandleInst = HandlInst([]int32{0, 1, 2, 3}[r.Intn(4)])
	this.Algo = randStringOrder(r)
	this.IsComplete = bool(bool(r.Intn(2) == 0))
	this.IsBooked = bool(bool(r.Intn(2) == 0))
	this.IsExpired = bool(bool(r.Intn(2) == 0))
	this.TradeBookingId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.TradeBookingId *= -1
	}
	this.OpenClose = randStringOrder(r)
	this.Source = randStringOrder(r)
	this.Trader = randStringOrder(r)
	this.TraderId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.TraderId *= -1
	}
	this.Machine = randStringOrder(r)
	this.Memo = randStringOrder(r)
	this.CreateDatetime = randStringOrder(r)
	this.SubmitDatetime = randStringOrder(r)
	if r.Intn(10) != 0 {
		v1 := r.Intn(10)
		this.Executions = make([]Execution, v1)
		for i := 0; i < v1; i++ {
			v2 := NewPopulatedExecution(r, easy)
			this.Executions[i] = *v2
		}
	}
	if r.Intn(10) != 0 {
		v3 := r.Intn(10)
		this.Allocations = make([]Allocation, v3)
		for i := 0; i < v3; i++ {
			v4 := NewPopulatedAllocation(r, easy)
			this.Allocations[i] = *v4
		}
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedOrder(r, 81)
	}
	return this
}

func NewPopulatedExecution(r randyOrder, easy bool) *Execution {
	this := &Execution{}
	this.ExecutionId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ExecutionId *= -1
	}
	this.OrderId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.OrderId *= -1
	}
	this.OrderKey = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.OrderKey *= -1
	}
	this.ClientOrderId = randStringOrder(r)
	this.BrokerOrderId = randStringOrder(r)
	this.BrokerExecId = randStringOrder(r)
	this.PrevBrokerExecId = randStringOrder(r)
	this.CancelReplaceByExececutionId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.CancelReplaceByExececutionId *= -1
	}
	this.OrderStatus = OrderStatus([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 100, 101, 102, 103, 110, 111, 112, 113, 120, 121, 122, 123, 125, 126, 130, 131, 132, 133, 134, 135}[r.Intn(35)])
	this.ExecType = Execution_ExecType([]int32{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18}[r.Intn(19)])
	this.Quantity = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Quantity *= -1
	}
	this.Price = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Price *= -1
	}
	this.Text = randStringOrder(r)
	this.Lastmkt = randStringOrder(r)
	this.ExecBroker = randStringOrder(r)
	this.LastLiquidity = LastLiquidityInd([]int32{0, 1, 2, 3, 4}[r.Intn(5)])
	this.CumQuantity = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.CumQuantity *= -1
	}
	this.AvgPrice = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.AvgPrice *= -1
	}
	this.CalcCumQuantity = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.CalcCumQuantity *= -1
	}
	this.CalcAvgPrice = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.CalcAvgPrice *= -1
	}
	this.BrokerExecDatetime = randStringOrder(r)
	this.CreateDatetime = randStringOrder(r)
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedOrder(r, 62)
	}
	return this
}

func NewPopulatedAllocation(r randyOrder, easy bool) *Allocation {
	this := &Allocation{}
	this.AllocationId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.AllocationId *= -1
	}
	this.OrderKey = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.OrderKey *= -1
	}
	this.StrategyId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.StrategyId *= -1
	}
	this.Quantity = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Quantity *= -1
	}
	this.Ratio = float64(r.Float64())
	if r.Intn(2) == 0 {
		this.Ratio *= -1
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedOrder(r, 12)
	}
	return this
}

func NewPopulatedNewOrderRequest(r randyOrder, easy bool) *NewOrderRequest {
	this := &NewOrderRequest{}
	if r.Intn(10) != 0 {
		this.Order = NewPopulatedOrder(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedOrder(r, 2)
	}
	return this
}

func NewPopulatedNewOrderResponse(r randyOrder, easy bool) *NewOrderResponse {
	this := &NewOrderResponse{}
	this.ErrorCode = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ErrorCode *= -1
	}
	if r.Intn(10) != 0 {
		v5 := randStringOrder(r)
		this.ErrorMessage = &v5
	}
	if r.Intn(10) != 0 {
		this.Order = NewPopulatedOrder(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedOrder(r, 11)
	}
	return this
}

func NewPopulatedCancelOrderRequest(r randyOrder, easy bool) *CancelOrderRequest {
	this := &CancelOrderRequest{}
	this.ClientGuid = randStringOrder(r)
	this.OrderId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.OrderId *= -1
	}
	this.OrderKey = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.OrderKey *= -1
	}
	this.Version = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.Version *= -1
	}
	this.Source = randStringOrder(r)
	this.Trader = randStringOrder(r)
	this.TraderId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.TraderId *= -1
	}
	this.Machine = randStringOrder(r)
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedOrder(r, 54)
	}
	return this
}

func NewPopulatedCancelOrderResponse(r randyOrder, easy bool) *CancelOrderResponse {
	this := &CancelOrderResponse{}
	this.ErrorCode = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ErrorCode *= -1
	}
	if r.Intn(10) != 0 {
		v6 := randStringOrder(r)
		this.ErrorMessage = &v6
	}
	if r.Intn(10) != 0 {
		this.Order = NewPopulatedOrder(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedOrder(r, 11)
	}
	return this
}

func NewPopulatedReplaceOrderRequest(r randyOrder, easy bool) *ReplaceOrderRequest {
	this := &ReplaceOrderRequest{}
	if r.Intn(10) != 0 {
		this.Order = NewPopulatedOrder(r, easy)
	}
	this.Source = randStringOrder(r)
	this.Trader = randStringOrder(r)
	this.TraderId = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.TraderId *= -1
	}
	this.Machine = randStringOrder(r)
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedOrder(r, 54)
	}
	return this
}

func NewPopulatedReplaceOrderResponse(r randyOrder, easy bool) *ReplaceOrderResponse {
	this := &ReplaceOrderResponse{}
	this.ErrorCode = int32(r.Int31())
	if r.Intn(2) == 0 {
		this.ErrorCode *= -1
	}
	if r.Intn(10) != 0 {
		v7 := randStringOrder(r)
		this.ErrorMessage = &v7
	}
	if r.Intn(10) != 0 {
		this.Order = NewPopulatedOrder(r, easy)
	}
	if !easy && r.Intn(10) != 0 {
		this.XXX_unrecognized = randUnrecognizedOrder(r, 11)
	}
	return this
}

type randyOrder interface {
	Float32() float32
	Float64() float64
	Int63() int64
	Int31() int32
	Uint32() uint32
	Intn(n int) int
}

func randUTF8RuneOrder(r randyOrder) rune {
	ru := r.Intn(62)
	if ru < 10 {
		return rune(ru + 48)
	} else if ru < 36 {
		return rune(ru + 55)
	}
	return rune(ru + 61)
}
func randStringOrder(r randyOrder) string {
	v8 := r.Intn(100)
	tmps := make([]rune, v8)
	for i := 0; i < v8; i++ {
		tmps[i] = randUTF8RuneOrder(r)
	}
	return string(tmps)
}
func randUnrecognizedOrder(r randyOrder, maxFieldNumber int) (data []byte) {
	l := r.Intn(5)
	for i := 0; i < l; i++ {
		wire := r.Intn(4)
		if wire == 3 {
			wire = 5
		}
		fieldNumber := maxFieldNumber + r.Intn(100)
		data = randFieldOrder(data, r, fieldNumber, wire)
	}
	return data
}
func randFieldOrder(data []byte, r randyOrder, fieldNumber int, wire int) []byte {
	key := uint32(fieldNumber)<<3 | uint32(wire)
	switch wire {
	case 0:
		data = encodeVarintPopulateOrder(data, uint64(key))
		v9 := r.Int63()
		if r.Intn(2) == 0 {
			v9 *= -1
		}
		data = encodeVarintPopulateOrder(data, uint64(v9))
	case 1:
		data = encodeVarintPopulateOrder(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	case 2:
		data = encodeVarintPopulateOrder(data, uint64(key))
		ll := r.Intn(100)
		data = encodeVarintPopulateOrder(data, uint64(ll))
		for j := 0; j < ll; j++ {
			data = append(data, byte(r.Intn(256)))
		}
	default:
		data = encodeVarintPopulateOrder(data, uint64(key))
		data = append(data, byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)), byte(r.Intn(256)))
	}
	return data
}
func encodeVarintPopulateOrder(data []byte, v uint64) []byte {
	for v >= 1<<7 {
		data = append(data, uint8(uint64(v)&0x7f|0x80))
		v >>= 7
	}
	data = append(data, uint8(v))
	return data
}
func (m *Order) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Order) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.ClientGuid)))
	i += copy(data[i:], m.ClientGuid)
	data[i] = 0x10
	i++
	i = encodeVarintOrder(data, i, uint64(m.OrderId))
	data[i] = 0x18
	i++
	i = encodeVarintOrder(data, i, uint64(m.OrderKey))
	data[i] = 0x20
	i++
	i = encodeVarintOrder(data, i, uint64(m.Version))
	data[i] = 0x28
	i++
	i = encodeVarintOrder(data, i, uint64(m.MessageType))
	data[i] = 0x30
	i++
	i = encodeVarintOrder(data, i, uint64(m.Side))
	data[i] = 0x39
	i++
	i = encodeFixed64Order(data, i, uint64(math.Float64bits(m.Quantity)))
	data[i] = 0x42
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Symbol)))
	i += copy(data[i:], m.Symbol)
	data[i] = 0x80
	i++
	data[i] = 0x1
	i++
	i = encodeVarintOrder(data, i, uint64(m.OrderType))
	data[i] = 0x88
	i++
	data[i] = 0x1
	i++
	i = encodeVarintOrder(data, i, uint64(m.Timeinforce))
	data[i] = 0x91
	i++
	data[i] = 0x1
	i++
	i = encodeFixed64Order(data, i, uint64(math.Float64bits(m.LimitPrice)))
	data[i] = 0x9a
	i++
	data[i] = 0x1
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Exchange)))
	i += copy(data[i:], m.Exchange)
	data[i] = 0xa2
	i++
	data[i] = 0x1
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Description)))
	i += copy(data[i:], m.Description)
	data[i] = 0xa9
	i++
	data[i] = 0x1
	i++
	i = encodeFixed64Order(data, i, uint64(math.Float64bits(m.FilledQuantity)))
	data[i] = 0xb1
	i++
	data[i] = 0x1
	i++
	i = encodeFixed64Order(data, i, uint64(math.Float64bits(m.FilledAvgPrice)))
	data[i] = 0xb8
	i++
	data[i] = 0x1
	i++
	i = encodeVarintOrder(data, i, uint64(m.OrderStatus))
	data[i] = 0xf0
	i++
	data[i] = 0x1
	i++
	i = encodeVarintOrder(data, i, uint64(m.AccountId))
	data[i] = 0xfa
	i++
	data[i] = 0x1
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.BrokerUserid)))
	i += copy(data[i:], m.BrokerUserid)
	data[i] = 0x82
	i++
	data[i] = 0x2
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.BrokerAccount)))
	i += copy(data[i:], m.BrokerAccount)
	data[i] = 0x8a
	i++
	data[i] = 0x2
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.MarketConnector)))
	i += copy(data[i:], m.MarketConnector)
	data[i] = 0xc2
	i++
	data[i] = 0x2
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.SettlCcy)))
	i += copy(data[i:], m.SettlCcy)
	data[i] = 0xc8
	i++
	data[i] = 0x2
	i++
	i = encodeVarintOrder(data, i, uint64(m.HandleInst))
	data[i] = 0xd2
	i++
	data[i] = 0x2
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Algo)))
	i += copy(data[i:], m.Algo)
	data[i] = 0xd8
	i++
	data[i] = 0x2
	i++
	if m.IsComplete {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	data[i] = 0xe0
	i++
	data[i] = 0x2
	i++
	if m.IsBooked {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	data[i] = 0xe8
	i++
	data[i] = 0x2
	i++
	if m.IsExpired {
		data[i] = 1
	} else {
		data[i] = 0
	}
	i++
	data[i] = 0xf0
	i++
	data[i] = 0x2
	i++
	i = encodeVarintOrder(data, i, uint64(m.TradeBookingId))
	data[i] = 0xfa
	i++
	data[i] = 0x2
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.OpenClose)))
	i += copy(data[i:], m.OpenClose)
	data[i] = 0x92
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Source)))
	i += copy(data[i:], m.Source)
	data[i] = 0x9a
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Trader)))
	i += copy(data[i:], m.Trader)
	data[i] = 0xa0
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(m.TraderId))
	data[i] = 0xaa
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Machine)))
	i += copy(data[i:], m.Machine)
	data[i] = 0xb2
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Memo)))
	i += copy(data[i:], m.Memo)
	data[i] = 0xe2
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.CreateDatetime)))
	i += copy(data[i:], m.CreateDatetime)
	data[i] = 0xea
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.SubmitDatetime)))
	i += copy(data[i:], m.SubmitDatetime)
	if len(m.Executions) > 0 {
		for _, msg := range m.Executions {
			data[i] = 0xb2
			i++
			data[i] = 0x4
			i++
			i = encodeVarintOrder(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Allocations) > 0 {
		for _, msg := range m.Allocations {
			data[i] = 0x82
			i++
			data[i] = 0x5
			i++
			i = encodeVarintOrder(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Execution) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Execution) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOrder(data, i, uint64(m.ExecutionId))
	data[i] = 0x10
	i++
	i = encodeVarintOrder(data, i, uint64(m.OrderId))
	data[i] = 0x18
	i++
	i = encodeVarintOrder(data, i, uint64(m.OrderKey))
	data[i] = 0x2a
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.ClientOrderId)))
	i += copy(data[i:], m.ClientOrderId)
	data[i] = 0x32
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.BrokerOrderId)))
	i += copy(data[i:], m.BrokerOrderId)
	data[i] = 0x3a
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.BrokerExecId)))
	i += copy(data[i:], m.BrokerExecId)
	data[i] = 0x42
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.PrevBrokerExecId)))
	i += copy(data[i:], m.PrevBrokerExecId)
	data[i] = 0x48
	i++
	i = encodeVarintOrder(data, i, uint64(m.CancelReplaceByExececutionId))
	data[i] = 0x50
	i++
	i = encodeVarintOrder(data, i, uint64(m.OrderStatus))
	data[i] = 0x58
	i++
	i = encodeVarintOrder(data, i, uint64(m.ExecType))
	data[i] = 0xa1
	i++
	data[i] = 0x1
	i++
	i = encodeFixed64Order(data, i, uint64(math.Float64bits(m.Quantity)))
	data[i] = 0xa9
	i++
	data[i] = 0x1
	i++
	i = encodeFixed64Order(data, i, uint64(math.Float64bits(m.Price)))
	data[i] = 0xf2
	i++
	data[i] = 0x1
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Text)))
	i += copy(data[i:], m.Text)
	data[i] = 0xfa
	i++
	data[i] = 0x1
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Lastmkt)))
	i += copy(data[i:], m.Lastmkt)
	data[i] = 0x82
	i++
	data[i] = 0x2
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.ExecBroker)))
	i += copy(data[i:], m.ExecBroker)
	data[i] = 0x88
	i++
	data[i] = 0x2
	i++
	i = encodeVarintOrder(data, i, uint64(m.LastLiquidity))
	data[i] = 0x91
	i++
	data[i] = 0x3
	i++
	i = encodeFixed64Order(data, i, uint64(math.Float64bits(m.CumQuantity)))
	data[i] = 0x99
	i++
	data[i] = 0x3
	i++
	i = encodeFixed64Order(data, i, uint64(math.Float64bits(m.AvgPrice)))
	data[i] = 0xa1
	i++
	data[i] = 0x3
	i++
	i = encodeFixed64Order(data, i, uint64(math.Float64bits(m.CalcCumQuantity)))
	data[i] = 0xa9
	i++
	data[i] = 0x3
	i++
	i = encodeFixed64Order(data, i, uint64(math.Float64bits(m.CalcAvgPrice)))
	data[i] = 0xe2
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.BrokerExecDatetime)))
	i += copy(data[i:], m.BrokerExecDatetime)
	data[i] = 0xea
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.CreateDatetime)))
	i += copy(data[i:], m.CreateDatetime)
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Allocation) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Allocation) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOrder(data, i, uint64(m.AllocationId))
	data[i] = 0x10
	i++
	i = encodeVarintOrder(data, i, uint64(m.OrderKey))
	data[i] = 0x18
	i++
	i = encodeVarintOrder(data, i, uint64(m.StrategyId))
	data[i] = 0x51
	i++
	i = encodeFixed64Order(data, i, uint64(math.Float64bits(m.Quantity)))
	data[i] = 0x59
	i++
	i = encodeFixed64Order(data, i, uint64(math.Float64bits(m.Ratio)))
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NewOrderRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewOrderRequest) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		data[i] = 0xa
		i++
		i = encodeVarintOrder(data, i, uint64(m.Order.Size()))
		n1, err := m.Order.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *NewOrderResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NewOrderResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOrder(data, i, uint64(m.ErrorCode))
	if m.ErrorMessage != nil {
		data[i] = 0x12
		i++
		i = encodeVarintOrder(data, i, uint64(len(*m.ErrorMessage)))
		i += copy(data[i:], *m.ErrorMessage)
	}
	if m.Order != nil {
		data[i] = 0x52
		i++
		i = encodeVarintOrder(data, i, uint64(m.Order.Size()))
		n2, err := m.Order.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CancelOrderRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CancelOrderRequest) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0xa
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.ClientGuid)))
	i += copy(data[i:], m.ClientGuid)
	data[i] = 0x10
	i++
	i = encodeVarintOrder(data, i, uint64(m.OrderId))
	data[i] = 0x18
	i++
	i = encodeVarintOrder(data, i, uint64(m.OrderKey))
	data[i] = 0x20
	i++
	i = encodeVarintOrder(data, i, uint64(m.Version))
	data[i] = 0x92
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Source)))
	i += copy(data[i:], m.Source)
	data[i] = 0x9a
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Trader)))
	i += copy(data[i:], m.Trader)
	data[i] = 0xa0
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(m.TraderId))
	data[i] = 0xaa
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Machine)))
	i += copy(data[i:], m.Machine)
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *CancelOrderResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CancelOrderResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOrder(data, i, uint64(m.ErrorCode))
	if m.ErrorMessage != nil {
		data[i] = 0x12
		i++
		i = encodeVarintOrder(data, i, uint64(len(*m.ErrorMessage)))
		i += copy(data[i:], *m.ErrorMessage)
	}
	if m.Order != nil {
		data[i] = 0x52
		i++
		i = encodeVarintOrder(data, i, uint64(m.Order.Size()))
		n3, err := m.Order.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReplaceOrderRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReplaceOrderRequest) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Order != nil {
		data[i] = 0xa
		i++
		i = encodeVarintOrder(data, i, uint64(m.Order.Size()))
		n4, err := m.Order.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	data[i] = 0x92
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Source)))
	i += copy(data[i:], m.Source)
	data[i] = 0x9a
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Trader)))
	i += copy(data[i:], m.Trader)
	data[i] = 0xa0
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(m.TraderId))
	data[i] = 0xaa
	i++
	data[i] = 0x3
	i++
	i = encodeVarintOrder(data, i, uint64(len(m.Machine)))
	i += copy(data[i:], m.Machine)
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ReplaceOrderResponse) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReplaceOrderResponse) MarshalTo(data []byte) (n int, err error) {
	var i int
	_ = i
	var l int
	_ = l
	data[i] = 0x8
	i++
	i = encodeVarintOrder(data, i, uint64(m.ErrorCode))
	if m.ErrorMessage != nil {
		data[i] = 0x12
		i++
		i = encodeVarintOrder(data, i, uint64(len(*m.ErrorMessage)))
		i += copy(data[i:], *m.ErrorMessage)
	}
	if m.Order != nil {
		data[i] = 0x52
		i++
		i = encodeVarintOrder(data, i, uint64(m.Order.Size()))
		n5, err := m.Order.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(data[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeFixed64Order(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Order(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintOrder(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (this *Order) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&order.Order{` +
		`ClientGuid:` + fmt.Sprintf("%#v", this.ClientGuid),
		`OrderId:` + fmt.Sprintf("%#v", this.OrderId),
		`OrderKey:` + fmt.Sprintf("%#v", this.OrderKey),
		`Version:` + fmt.Sprintf("%#v", this.Version),
		`MessageType:` + fmt.Sprintf("%#v", this.MessageType),
		`Side:` + fmt.Sprintf("%#v", this.Side),
		`Quantity:` + fmt.Sprintf("%#v", this.Quantity),
		`Symbol:` + fmt.Sprintf("%#v", this.Symbol),
		`OrderType:` + fmt.Sprintf("%#v", this.OrderType),
		`Timeinforce:` + fmt.Sprintf("%#v", this.Timeinforce),
		`LimitPrice:` + fmt.Sprintf("%#v", this.LimitPrice),
		`Exchange:` + fmt.Sprintf("%#v", this.Exchange),
		`Description:` + fmt.Sprintf("%#v", this.Description),
		`FilledQuantity:` + fmt.Sprintf("%#v", this.FilledQuantity),
		`FilledAvgPrice:` + fmt.Sprintf("%#v", this.FilledAvgPrice),
		`OrderStatus:` + fmt.Sprintf("%#v", this.OrderStatus),
		`AccountId:` + fmt.Sprintf("%#v", this.AccountId),
		`BrokerUserid:` + fmt.Sprintf("%#v", this.BrokerUserid),
		`BrokerAccount:` + fmt.Sprintf("%#v", this.BrokerAccount),
		`MarketConnector:` + fmt.Sprintf("%#v", this.MarketConnector),
		`SettlCcy:` + fmt.Sprintf("%#v", this.SettlCcy),
		`HandleInst:` + fmt.Sprintf("%#v", this.HandleInst),
		`Algo:` + fmt.Sprintf("%#v", this.Algo),
		`IsComplete:` + fmt.Sprintf("%#v", this.IsComplete),
		`IsBooked:` + fmt.Sprintf("%#v", this.IsBooked),
		`IsExpired:` + fmt.Sprintf("%#v", this.IsExpired),
		`TradeBookingId:` + fmt.Sprintf("%#v", this.TradeBookingId),
		`OpenClose:` + fmt.Sprintf("%#v", this.OpenClose),
		`Source:` + fmt.Sprintf("%#v", this.Source),
		`Trader:` + fmt.Sprintf("%#v", this.Trader),
		`TraderId:` + fmt.Sprintf("%#v", this.TraderId),
		`Machine:` + fmt.Sprintf("%#v", this.Machine),
		`Memo:` + fmt.Sprintf("%#v", this.Memo),
		`CreateDatetime:` + fmt.Sprintf("%#v", this.CreateDatetime),
		`SubmitDatetime:` + fmt.Sprintf("%#v", this.SubmitDatetime),
		`Executions:` + strings.Replace(fmt.Sprintf("%#v", this.Executions), `&`, ``, 1),
		`Allocations:` + strings.Replace(fmt.Sprintf("%#v", this.Allocations), `&`, ``, 1),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *Execution) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&order.Execution{` +
		`ExecutionId:` + fmt.Sprintf("%#v", this.ExecutionId),
		`OrderId:` + fmt.Sprintf("%#v", this.OrderId),
		`OrderKey:` + fmt.Sprintf("%#v", this.OrderKey),
		`ClientOrderId:` + fmt.Sprintf("%#v", this.ClientOrderId),
		`BrokerOrderId:` + fmt.Sprintf("%#v", this.BrokerOrderId),
		`BrokerExecId:` + fmt.Sprintf("%#v", this.BrokerExecId),
		`PrevBrokerExecId:` + fmt.Sprintf("%#v", this.PrevBrokerExecId),
		`CancelReplaceByExececutionId:` + fmt.Sprintf("%#v", this.CancelReplaceByExececutionId),
		`OrderStatus:` + fmt.Sprintf("%#v", this.OrderStatus),
		`ExecType:` + fmt.Sprintf("%#v", this.ExecType),
		`Quantity:` + fmt.Sprintf("%#v", this.Quantity),
		`Price:` + fmt.Sprintf("%#v", this.Price),
		`Text:` + fmt.Sprintf("%#v", this.Text),
		`Lastmkt:` + fmt.Sprintf("%#v", this.Lastmkt),
		`ExecBroker:` + fmt.Sprintf("%#v", this.ExecBroker),
		`LastLiquidity:` + fmt.Sprintf("%#v", this.LastLiquidity),
		`CumQuantity:` + fmt.Sprintf("%#v", this.CumQuantity),
		`AvgPrice:` + fmt.Sprintf("%#v", this.AvgPrice),
		`CalcCumQuantity:` + fmt.Sprintf("%#v", this.CalcCumQuantity),
		`CalcAvgPrice:` + fmt.Sprintf("%#v", this.CalcAvgPrice),
		`BrokerExecDatetime:` + fmt.Sprintf("%#v", this.BrokerExecDatetime),
		`CreateDatetime:` + fmt.Sprintf("%#v", this.CreateDatetime),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *Allocation) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&order.Allocation{` +
		`AllocationId:` + fmt.Sprintf("%#v", this.AllocationId),
		`OrderKey:` + fmt.Sprintf("%#v", this.OrderKey),
		`StrategyId:` + fmt.Sprintf("%#v", this.StrategyId),
		`Quantity:` + fmt.Sprintf("%#v", this.Quantity),
		`Ratio:` + fmt.Sprintf("%#v", this.Ratio),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *NewOrderRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&order.NewOrderRequest{` +
		`Order:` + fmt.Sprintf("%#v", this.Order),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *NewOrderResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&order.NewOrderResponse{` +
		`ErrorCode:` + fmt.Sprintf("%#v", this.ErrorCode),
		`ErrorMessage:` + valueToGoStringOrder(this.ErrorMessage, "string"),
		`Order:` + fmt.Sprintf("%#v", this.Order),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *CancelOrderRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&order.CancelOrderRequest{` +
		`ClientGuid:` + fmt.Sprintf("%#v", this.ClientGuid),
		`OrderId:` + fmt.Sprintf("%#v", this.OrderId),
		`OrderKey:` + fmt.Sprintf("%#v", this.OrderKey),
		`Version:` + fmt.Sprintf("%#v", this.Version),
		`Source:` + fmt.Sprintf("%#v", this.Source),
		`Trader:` + fmt.Sprintf("%#v", this.Trader),
		`TraderId:` + fmt.Sprintf("%#v", this.TraderId),
		`Machine:` + fmt.Sprintf("%#v", this.Machine),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *CancelOrderResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&order.CancelOrderResponse{` +
		`ErrorCode:` + fmt.Sprintf("%#v", this.ErrorCode),
		`ErrorMessage:` + valueToGoStringOrder(this.ErrorMessage, "string"),
		`Order:` + fmt.Sprintf("%#v", this.Order),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *ReplaceOrderRequest) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&order.ReplaceOrderRequest{` +
		`Order:` + fmt.Sprintf("%#v", this.Order),
		`Source:` + fmt.Sprintf("%#v", this.Source),
		`Trader:` + fmt.Sprintf("%#v", this.Trader),
		`TraderId:` + fmt.Sprintf("%#v", this.TraderId),
		`Machine:` + fmt.Sprintf("%#v", this.Machine),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func (this *ReplaceOrderResponse) GoString() string {
	if this == nil {
		return "nil"
	}
	s := strings.Join([]string{`&order.ReplaceOrderResponse{` +
		`ErrorCode:` + fmt.Sprintf("%#v", this.ErrorCode),
		`ErrorMessage:` + valueToGoStringOrder(this.ErrorMessage, "string"),
		`Order:` + fmt.Sprintf("%#v", this.Order),
		`XXX_unrecognized:` + fmt.Sprintf("%#v", this.XXX_unrecognized) + `}`}, ", ")
	return s
}
func valueToGoStringOrder(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}
func extensionToGoStringOrder(e map[int32]github_com_gogo_protobuf_proto.Extension) string {
	if e == nil {
		return "nil"
	}
	s := "map[int32]proto.Extension{"
	keys := make([]int, 0, len(e))
	for k := range e {
		keys = append(keys, int(k))
	}
	sort.Ints(keys)
	ss := []string{}
	for _, k := range keys {
		ss = append(ss, strconv.Itoa(k)+": "+e[int32(k)].GoString())
	}
	s += strings.Join(ss, ",") + "}"
	return s
}
func (this *Order) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Order)
	if !ok {
		return fmt.Errorf("that is not of type *Order")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Order but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Orderbut is not nil && this == nil")
	}
	if this.ClientGuid != that1.ClientGuid {
		return fmt.Errorf("ClientGuid this(%v) Not Equal that(%v)", this.ClientGuid, that1.ClientGuid)
	}
	if this.OrderId != that1.OrderId {
		return fmt.Errorf("OrderId this(%v) Not Equal that(%v)", this.OrderId, that1.OrderId)
	}
	if this.OrderKey != that1.OrderKey {
		return fmt.Errorf("OrderKey this(%v) Not Equal that(%v)", this.OrderKey, that1.OrderKey)
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if this.MessageType != that1.MessageType {
		return fmt.Errorf("MessageType this(%v) Not Equal that(%v)", this.MessageType, that1.MessageType)
	}
	if this.Side != that1.Side {
		return fmt.Errorf("Side this(%v) Not Equal that(%v)", this.Side, that1.Side)
	}
	if this.Quantity != that1.Quantity {
		return fmt.Errorf("Quantity this(%v) Not Equal that(%v)", this.Quantity, that1.Quantity)
	}
	if this.Symbol != that1.Symbol {
		return fmt.Errorf("Symbol this(%v) Not Equal that(%v)", this.Symbol, that1.Symbol)
	}
	if this.OrderType != that1.OrderType {
		return fmt.Errorf("OrderType this(%v) Not Equal that(%v)", this.OrderType, that1.OrderType)
	}
	if this.Timeinforce != that1.Timeinforce {
		return fmt.Errorf("Timeinforce this(%v) Not Equal that(%v)", this.Timeinforce, that1.Timeinforce)
	}
	if this.LimitPrice != that1.LimitPrice {
		return fmt.Errorf("LimitPrice this(%v) Not Equal that(%v)", this.LimitPrice, that1.LimitPrice)
	}
	if this.Exchange != that1.Exchange {
		return fmt.Errorf("Exchange this(%v) Not Equal that(%v)", this.Exchange, that1.Exchange)
	}
	if this.Description != that1.Description {
		return fmt.Errorf("Description this(%v) Not Equal that(%v)", this.Description, that1.Description)
	}
	if this.FilledQuantity != that1.FilledQuantity {
		return fmt.Errorf("FilledQuantity this(%v) Not Equal that(%v)", this.FilledQuantity, that1.FilledQuantity)
	}
	if this.FilledAvgPrice != that1.FilledAvgPrice {
		return fmt.Errorf("FilledAvgPrice this(%v) Not Equal that(%v)", this.FilledAvgPrice, that1.FilledAvgPrice)
	}
	if this.OrderStatus != that1.OrderStatus {
		return fmt.Errorf("OrderStatus this(%v) Not Equal that(%v)", this.OrderStatus, that1.OrderStatus)
	}
	if this.AccountId != that1.AccountId {
		return fmt.Errorf("AccountId this(%v) Not Equal that(%v)", this.AccountId, that1.AccountId)
	}
	if this.BrokerUserid != that1.BrokerUserid {
		return fmt.Errorf("BrokerUserid this(%v) Not Equal that(%v)", this.BrokerUserid, that1.BrokerUserid)
	}
	if this.BrokerAccount != that1.BrokerAccount {
		return fmt.Errorf("BrokerAccount this(%v) Not Equal that(%v)", this.BrokerAccount, that1.BrokerAccount)
	}
	if this.MarketConnector != that1.MarketConnector {
		return fmt.Errorf("MarketConnector this(%v) Not Equal that(%v)", this.MarketConnector, that1.MarketConnector)
	}
	if this.SettlCcy != that1.SettlCcy {
		return fmt.Errorf("SettlCcy this(%v) Not Equal that(%v)", this.SettlCcy, that1.SettlCcy)
	}
	if this.HandleInst != that1.HandleInst {
		return fmt.Errorf("HandleInst this(%v) Not Equal that(%v)", this.HandleInst, that1.HandleInst)
	}
	if this.Algo != that1.Algo {
		return fmt.Errorf("Algo this(%v) Not Equal that(%v)", this.Algo, that1.Algo)
	}
	if this.IsComplete != that1.IsComplete {
		return fmt.Errorf("IsComplete this(%v) Not Equal that(%v)", this.IsComplete, that1.IsComplete)
	}
	if this.IsBooked != that1.IsBooked {
		return fmt.Errorf("IsBooked this(%v) Not Equal that(%v)", this.IsBooked, that1.IsBooked)
	}
	if this.IsExpired != that1.IsExpired {
		return fmt.Errorf("IsExpired this(%v) Not Equal that(%v)", this.IsExpired, that1.IsExpired)
	}
	if this.TradeBookingId != that1.TradeBookingId {
		return fmt.Errorf("TradeBookingId this(%v) Not Equal that(%v)", this.TradeBookingId, that1.TradeBookingId)
	}
	if this.OpenClose != that1.OpenClose {
		return fmt.Errorf("OpenClose this(%v) Not Equal that(%v)", this.OpenClose, that1.OpenClose)
	}
	if this.Source != that1.Source {
		return fmt.Errorf("Source this(%v) Not Equal that(%v)", this.Source, that1.Source)
	}
	if this.Trader != that1.Trader {
		return fmt.Errorf("Trader this(%v) Not Equal that(%v)", this.Trader, that1.Trader)
	}
	if this.TraderId != that1.TraderId {
		return fmt.Errorf("TraderId this(%v) Not Equal that(%v)", this.TraderId, that1.TraderId)
	}
	if this.Machine != that1.Machine {
		return fmt.Errorf("Machine this(%v) Not Equal that(%v)", this.Machine, that1.Machine)
	}
	if this.Memo != that1.Memo {
		return fmt.Errorf("Memo this(%v) Not Equal that(%v)", this.Memo, that1.Memo)
	}
	if this.CreateDatetime != that1.CreateDatetime {
		return fmt.Errorf("CreateDatetime this(%v) Not Equal that(%v)", this.CreateDatetime, that1.CreateDatetime)
	}
	if this.SubmitDatetime != that1.SubmitDatetime {
		return fmt.Errorf("SubmitDatetime this(%v) Not Equal that(%v)", this.SubmitDatetime, that1.SubmitDatetime)
	}
	if len(this.Executions) != len(that1.Executions) {
		return fmt.Errorf("Executions this(%v) Not Equal that(%v)", len(this.Executions), len(that1.Executions))
	}
	for i := range this.Executions {
		if !this.Executions[i].Equal(&that1.Executions[i]) {
			return fmt.Errorf("Executions this[%v](%v) Not Equal that[%v](%v)", i, this.Executions[i], i, that1.Executions[i])
		}
	}
	if len(this.Allocations) != len(that1.Allocations) {
		return fmt.Errorf("Allocations this(%v) Not Equal that(%v)", len(this.Allocations), len(that1.Allocations))
	}
	for i := range this.Allocations {
		if !this.Allocations[i].Equal(&that1.Allocations[i]) {
			return fmt.Errorf("Allocations this[%v](%v) Not Equal that[%v](%v)", i, this.Allocations[i], i, that1.Allocations[i])
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Order) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Order)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ClientGuid != that1.ClientGuid {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	if this.OrderKey != that1.OrderKey {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.MessageType != that1.MessageType {
		return false
	}
	if this.Side != that1.Side {
		return false
	}
	if this.Quantity != that1.Quantity {
		return false
	}
	if this.Symbol != that1.Symbol {
		return false
	}
	if this.OrderType != that1.OrderType {
		return false
	}
	if this.Timeinforce != that1.Timeinforce {
		return false
	}
	if this.LimitPrice != that1.LimitPrice {
		return false
	}
	if this.Exchange != that1.Exchange {
		return false
	}
	if this.Description != that1.Description {
		return false
	}
	if this.FilledQuantity != that1.FilledQuantity {
		return false
	}
	if this.FilledAvgPrice != that1.FilledAvgPrice {
		return false
	}
	if this.OrderStatus != that1.OrderStatus {
		return false
	}
	if this.AccountId != that1.AccountId {
		return false
	}
	if this.BrokerUserid != that1.BrokerUserid {
		return false
	}
	if this.BrokerAccount != that1.BrokerAccount {
		return false
	}
	if this.MarketConnector != that1.MarketConnector {
		return false
	}
	if this.SettlCcy != that1.SettlCcy {
		return false
	}
	if this.HandleInst != that1.HandleInst {
		return false
	}
	if this.Algo != that1.Algo {
		return false
	}
	if this.IsComplete != that1.IsComplete {
		return false
	}
	if this.IsBooked != that1.IsBooked {
		return false
	}
	if this.IsExpired != that1.IsExpired {
		return false
	}
	if this.TradeBookingId != that1.TradeBookingId {
		return false
	}
	if this.OpenClose != that1.OpenClose {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	if this.Trader != that1.Trader {
		return false
	}
	if this.TraderId != that1.TraderId {
		return false
	}
	if this.Machine != that1.Machine {
		return false
	}
	if this.Memo != that1.Memo {
		return false
	}
	if this.CreateDatetime != that1.CreateDatetime {
		return false
	}
	if this.SubmitDatetime != that1.SubmitDatetime {
		return false
	}
	if len(this.Executions) != len(that1.Executions) {
		return false
	}
	for i := range this.Executions {
		if !this.Executions[i].Equal(&that1.Executions[i]) {
			return false
		}
	}
	if len(this.Allocations) != len(that1.Allocations) {
		return false
	}
	for i := range this.Allocations {
		if !this.Allocations[i].Equal(&that1.Allocations[i]) {
			return false
		}
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Execution) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Execution)
	if !ok {
		return fmt.Errorf("that is not of type *Execution")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Execution but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Executionbut is not nil && this == nil")
	}
	if this.ExecutionId != that1.ExecutionId {
		return fmt.Errorf("ExecutionId this(%v) Not Equal that(%v)", this.ExecutionId, that1.ExecutionId)
	}
	if this.OrderId != that1.OrderId {
		return fmt.Errorf("OrderId this(%v) Not Equal that(%v)", this.OrderId, that1.OrderId)
	}
	if this.OrderKey != that1.OrderKey {
		return fmt.Errorf("OrderKey this(%v) Not Equal that(%v)", this.OrderKey, that1.OrderKey)
	}
	if this.ClientOrderId != that1.ClientOrderId {
		return fmt.Errorf("ClientOrderId this(%v) Not Equal that(%v)", this.ClientOrderId, that1.ClientOrderId)
	}
	if this.BrokerOrderId != that1.BrokerOrderId {
		return fmt.Errorf("BrokerOrderId this(%v) Not Equal that(%v)", this.BrokerOrderId, that1.BrokerOrderId)
	}
	if this.BrokerExecId != that1.BrokerExecId {
		return fmt.Errorf("BrokerExecId this(%v) Not Equal that(%v)", this.BrokerExecId, that1.BrokerExecId)
	}
	if this.PrevBrokerExecId != that1.PrevBrokerExecId {
		return fmt.Errorf("PrevBrokerExecId this(%v) Not Equal that(%v)", this.PrevBrokerExecId, that1.PrevBrokerExecId)
	}
	if this.CancelReplaceByExececutionId != that1.CancelReplaceByExececutionId {
		return fmt.Errorf("CancelReplaceByExececutionId this(%v) Not Equal that(%v)", this.CancelReplaceByExececutionId, that1.CancelReplaceByExececutionId)
	}
	if this.OrderStatus != that1.OrderStatus {
		return fmt.Errorf("OrderStatus this(%v) Not Equal that(%v)", this.OrderStatus, that1.OrderStatus)
	}
	if this.ExecType != that1.ExecType {
		return fmt.Errorf("ExecType this(%v) Not Equal that(%v)", this.ExecType, that1.ExecType)
	}
	if this.Quantity != that1.Quantity {
		return fmt.Errorf("Quantity this(%v) Not Equal that(%v)", this.Quantity, that1.Quantity)
	}
	if this.Price != that1.Price {
		return fmt.Errorf("Price this(%v) Not Equal that(%v)", this.Price, that1.Price)
	}
	if this.Text != that1.Text {
		return fmt.Errorf("Text this(%v) Not Equal that(%v)", this.Text, that1.Text)
	}
	if this.Lastmkt != that1.Lastmkt {
		return fmt.Errorf("Lastmkt this(%v) Not Equal that(%v)", this.Lastmkt, that1.Lastmkt)
	}
	if this.ExecBroker != that1.ExecBroker {
		return fmt.Errorf("ExecBroker this(%v) Not Equal that(%v)", this.ExecBroker, that1.ExecBroker)
	}
	if this.LastLiquidity != that1.LastLiquidity {
		return fmt.Errorf("LastLiquidity this(%v) Not Equal that(%v)", this.LastLiquidity, that1.LastLiquidity)
	}
	if this.CumQuantity != that1.CumQuantity {
		return fmt.Errorf("CumQuantity this(%v) Not Equal that(%v)", this.CumQuantity, that1.CumQuantity)
	}
	if this.AvgPrice != that1.AvgPrice {
		return fmt.Errorf("AvgPrice this(%v) Not Equal that(%v)", this.AvgPrice, that1.AvgPrice)
	}
	if this.CalcCumQuantity != that1.CalcCumQuantity {
		return fmt.Errorf("CalcCumQuantity this(%v) Not Equal that(%v)", this.CalcCumQuantity, that1.CalcCumQuantity)
	}
	if this.CalcAvgPrice != that1.CalcAvgPrice {
		return fmt.Errorf("CalcAvgPrice this(%v) Not Equal that(%v)", this.CalcAvgPrice, that1.CalcAvgPrice)
	}
	if this.BrokerExecDatetime != that1.BrokerExecDatetime {
		return fmt.Errorf("BrokerExecDatetime this(%v) Not Equal that(%v)", this.BrokerExecDatetime, that1.BrokerExecDatetime)
	}
	if this.CreateDatetime != that1.CreateDatetime {
		return fmt.Errorf("CreateDatetime this(%v) Not Equal that(%v)", this.CreateDatetime, that1.CreateDatetime)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Execution) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Execution)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ExecutionId != that1.ExecutionId {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	if this.OrderKey != that1.OrderKey {
		return false
	}
	if this.ClientOrderId != that1.ClientOrderId {
		return false
	}
	if this.BrokerOrderId != that1.BrokerOrderId {
		return false
	}
	if this.BrokerExecId != that1.BrokerExecId {
		return false
	}
	if this.PrevBrokerExecId != that1.PrevBrokerExecId {
		return false
	}
	if this.CancelReplaceByExececutionId != that1.CancelReplaceByExececutionId {
		return false
	}
	if this.OrderStatus != that1.OrderStatus {
		return false
	}
	if this.ExecType != that1.ExecType {
		return false
	}
	if this.Quantity != that1.Quantity {
		return false
	}
	if this.Price != that1.Price {
		return false
	}
	if this.Text != that1.Text {
		return false
	}
	if this.Lastmkt != that1.Lastmkt {
		return false
	}
	if this.ExecBroker != that1.ExecBroker {
		return false
	}
	if this.LastLiquidity != that1.LastLiquidity {
		return false
	}
	if this.CumQuantity != that1.CumQuantity {
		return false
	}
	if this.AvgPrice != that1.AvgPrice {
		return false
	}
	if this.CalcCumQuantity != that1.CalcCumQuantity {
		return false
	}
	if this.CalcAvgPrice != that1.CalcAvgPrice {
		return false
	}
	if this.BrokerExecDatetime != that1.BrokerExecDatetime {
		return false
	}
	if this.CreateDatetime != that1.CreateDatetime {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *Allocation) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*Allocation)
	if !ok {
		return fmt.Errorf("that is not of type *Allocation")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *Allocation but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *Allocationbut is not nil && this == nil")
	}
	if this.AllocationId != that1.AllocationId {
		return fmt.Errorf("AllocationId this(%v) Not Equal that(%v)", this.AllocationId, that1.AllocationId)
	}
	if this.OrderKey != that1.OrderKey {
		return fmt.Errorf("OrderKey this(%v) Not Equal that(%v)", this.OrderKey, that1.OrderKey)
	}
	if this.StrategyId != that1.StrategyId {
		return fmt.Errorf("StrategyId this(%v) Not Equal that(%v)", this.StrategyId, that1.StrategyId)
	}
	if this.Quantity != that1.Quantity {
		return fmt.Errorf("Quantity this(%v) Not Equal that(%v)", this.Quantity, that1.Quantity)
	}
	if this.Ratio != that1.Ratio {
		return fmt.Errorf("Ratio this(%v) Not Equal that(%v)", this.Ratio, that1.Ratio)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *Allocation) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*Allocation)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.AllocationId != that1.AllocationId {
		return false
	}
	if this.OrderKey != that1.OrderKey {
		return false
	}
	if this.StrategyId != that1.StrategyId {
		return false
	}
	if this.Quantity != that1.Quantity {
		return false
	}
	if this.Ratio != that1.Ratio {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *NewOrderRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NewOrderRequest)
	if !ok {
		return fmt.Errorf("that is not of type *NewOrderRequest")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NewOrderRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NewOrderRequestbut is not nil && this == nil")
	}
	if !this.Order.Equal(that1.Order) {
		return fmt.Errorf("Order this(%v) Not Equal that(%v)", this.Order, that1.Order)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *NewOrderRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NewOrderRequest)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Order.Equal(that1.Order) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *NewOrderResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*NewOrderResponse)
	if !ok {
		return fmt.Errorf("that is not of type *NewOrderResponse")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *NewOrderResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *NewOrderResponsebut is not nil && this == nil")
	}
	if this.ErrorCode != that1.ErrorCode {
		return fmt.Errorf("ErrorCode this(%v) Not Equal that(%v)", this.ErrorCode, that1.ErrorCode)
	}
	if this.ErrorMessage != nil && that1.ErrorMessage != nil {
		if *this.ErrorMessage != *that1.ErrorMessage {
			return fmt.Errorf("ErrorMessage this(%v) Not Equal that(%v)", *this.ErrorMessage, *that1.ErrorMessage)
		}
	} else if this.ErrorMessage != nil {
		return fmt.Errorf("this.ErrorMessage == nil && that.ErrorMessage != nil")
	} else if that1.ErrorMessage != nil {
		return fmt.Errorf("ErrorMessage this(%v) Not Equal that(%v)", this.ErrorMessage, that1.ErrorMessage)
	}
	if !this.Order.Equal(that1.Order) {
		return fmt.Errorf("Order this(%v) Not Equal that(%v)", this.Order, that1.Order)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *NewOrderResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*NewOrderResponse)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.ErrorMessage != nil && that1.ErrorMessage != nil {
		if *this.ErrorMessage != *that1.ErrorMessage {
			return false
		}
	} else if this.ErrorMessage != nil {
		return false
	} else if that1.ErrorMessage != nil {
		return false
	}
	if !this.Order.Equal(that1.Order) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *CancelOrderRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CancelOrderRequest)
	if !ok {
		return fmt.Errorf("that is not of type *CancelOrderRequest")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CancelOrderRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CancelOrderRequestbut is not nil && this == nil")
	}
	if this.ClientGuid != that1.ClientGuid {
		return fmt.Errorf("ClientGuid this(%v) Not Equal that(%v)", this.ClientGuid, that1.ClientGuid)
	}
	if this.OrderId != that1.OrderId {
		return fmt.Errorf("OrderId this(%v) Not Equal that(%v)", this.OrderId, that1.OrderId)
	}
	if this.OrderKey != that1.OrderKey {
		return fmt.Errorf("OrderKey this(%v) Not Equal that(%v)", this.OrderKey, that1.OrderKey)
	}
	if this.Version != that1.Version {
		return fmt.Errorf("Version this(%v) Not Equal that(%v)", this.Version, that1.Version)
	}
	if this.Source != that1.Source {
		return fmt.Errorf("Source this(%v) Not Equal that(%v)", this.Source, that1.Source)
	}
	if this.Trader != that1.Trader {
		return fmt.Errorf("Trader this(%v) Not Equal that(%v)", this.Trader, that1.Trader)
	}
	if this.TraderId != that1.TraderId {
		return fmt.Errorf("TraderId this(%v) Not Equal that(%v)", this.TraderId, that1.TraderId)
	}
	if this.Machine != that1.Machine {
		return fmt.Errorf("Machine this(%v) Not Equal that(%v)", this.Machine, that1.Machine)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *CancelOrderRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CancelOrderRequest)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ClientGuid != that1.ClientGuid {
		return false
	}
	if this.OrderId != that1.OrderId {
		return false
	}
	if this.OrderKey != that1.OrderKey {
		return false
	}
	if this.Version != that1.Version {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	if this.Trader != that1.Trader {
		return false
	}
	if this.TraderId != that1.TraderId {
		return false
	}
	if this.Machine != that1.Machine {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *CancelOrderResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*CancelOrderResponse)
	if !ok {
		return fmt.Errorf("that is not of type *CancelOrderResponse")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *CancelOrderResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *CancelOrderResponsebut is not nil && this == nil")
	}
	if this.ErrorCode != that1.ErrorCode {
		return fmt.Errorf("ErrorCode this(%v) Not Equal that(%v)", this.ErrorCode, that1.ErrorCode)
	}
	if this.ErrorMessage != nil && that1.ErrorMessage != nil {
		if *this.ErrorMessage != *that1.ErrorMessage {
			return fmt.Errorf("ErrorMessage this(%v) Not Equal that(%v)", *this.ErrorMessage, *that1.ErrorMessage)
		}
	} else if this.ErrorMessage != nil {
		return fmt.Errorf("this.ErrorMessage == nil && that.ErrorMessage != nil")
	} else if that1.ErrorMessage != nil {
		return fmt.Errorf("ErrorMessage this(%v) Not Equal that(%v)", this.ErrorMessage, that1.ErrorMessage)
	}
	if !this.Order.Equal(that1.Order) {
		return fmt.Errorf("Order this(%v) Not Equal that(%v)", this.Order, that1.Order)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *CancelOrderResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*CancelOrderResponse)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.ErrorMessage != nil && that1.ErrorMessage != nil {
		if *this.ErrorMessage != *that1.ErrorMessage {
			return false
		}
	} else if this.ErrorMessage != nil {
		return false
	} else if that1.ErrorMessage != nil {
		return false
	}
	if !this.Order.Equal(that1.Order) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ReplaceOrderRequest) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ReplaceOrderRequest)
	if !ok {
		return fmt.Errorf("that is not of type *ReplaceOrderRequest")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ReplaceOrderRequest but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ReplaceOrderRequestbut is not nil && this == nil")
	}
	if !this.Order.Equal(that1.Order) {
		return fmt.Errorf("Order this(%v) Not Equal that(%v)", this.Order, that1.Order)
	}
	if this.Source != that1.Source {
		return fmt.Errorf("Source this(%v) Not Equal that(%v)", this.Source, that1.Source)
	}
	if this.Trader != that1.Trader {
		return fmt.Errorf("Trader this(%v) Not Equal that(%v)", this.Trader, that1.Trader)
	}
	if this.TraderId != that1.TraderId {
		return fmt.Errorf("TraderId this(%v) Not Equal that(%v)", this.TraderId, that1.TraderId)
	}
	if this.Machine != that1.Machine {
		return fmt.Errorf("Machine this(%v) Not Equal that(%v)", this.Machine, that1.Machine)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ReplaceOrderRequest) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ReplaceOrderRequest)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if !this.Order.Equal(that1.Order) {
		return false
	}
	if this.Source != that1.Source {
		return false
	}
	if this.Trader != that1.Trader {
		return false
	}
	if this.TraderId != that1.TraderId {
		return false
	}
	if this.Machine != that1.Machine {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
func (this *ReplaceOrderResponse) VerboseEqual(that interface{}) error {
	if that == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that == nil && this != nil")
	}

	that1, ok := that.(*ReplaceOrderResponse)
	if !ok {
		return fmt.Errorf("that is not of type *ReplaceOrderResponse")
	}
	if that1 == nil {
		if this == nil {
			return nil
		}
		return fmt.Errorf("that is type *ReplaceOrderResponse but is nil && this != nil")
	} else if this == nil {
		return fmt.Errorf("that is type *ReplaceOrderResponsebut is not nil && this == nil")
	}
	if this.ErrorCode != that1.ErrorCode {
		return fmt.Errorf("ErrorCode this(%v) Not Equal that(%v)", this.ErrorCode, that1.ErrorCode)
	}
	if this.ErrorMessage != nil && that1.ErrorMessage != nil {
		if *this.ErrorMessage != *that1.ErrorMessage {
			return fmt.Errorf("ErrorMessage this(%v) Not Equal that(%v)", *this.ErrorMessage, *that1.ErrorMessage)
		}
	} else if this.ErrorMessage != nil {
		return fmt.Errorf("this.ErrorMessage == nil && that.ErrorMessage != nil")
	} else if that1.ErrorMessage != nil {
		return fmt.Errorf("ErrorMessage this(%v) Not Equal that(%v)", this.ErrorMessage, that1.ErrorMessage)
	}
	if !this.Order.Equal(that1.Order) {
		return fmt.Errorf("Order this(%v) Not Equal that(%v)", this.Order, that1.Order)
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return fmt.Errorf("XXX_unrecognized this(%v) Not Equal that(%v)", this.XXX_unrecognized, that1.XXX_unrecognized)
	}
	return nil
}
func (this *ReplaceOrderResponse) Equal(that interface{}) bool {
	if that == nil {
		if this == nil {
			return true
		}
		return false
	}

	that1, ok := that.(*ReplaceOrderResponse)
	if !ok {
		return false
	}
	if that1 == nil {
		if this == nil {
			return true
		}
		return false
	} else if this == nil {
		return false
	}
	if this.ErrorCode != that1.ErrorCode {
		return false
	}
	if this.ErrorMessage != nil && that1.ErrorMessage != nil {
		if *this.ErrorMessage != *that1.ErrorMessage {
			return false
		}
	} else if this.ErrorMessage != nil {
		return false
	} else if that1.ErrorMessage != nil {
		return false
	}
	if !this.Order.Equal(that1.Order) {
		return false
	}
	if !bytes.Equal(this.XXX_unrecognized, that1.XXX_unrecognized) {
		return false
	}
	return true
}
